import React from 'react';
import { render, screen, act, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { AnnotationProvider, useAnnotations } from './AnnotationContext';
import { UserProvider } from './UserContext';
import { AnnotationManager } from '../utils/AnnotationManager';
import { TextSelection, AreaCoordinates, RectangleCoordinates } from '../types/annotation.types';

// Mock the AnnotationManager
const mockAnnotationManager = {
  getAnnotations: jest.fn(),
  createHighlight: jest.fn(),
  updateHighlight: jest.fn(),
  deleteHighlight: jest.fn(),
  createBookmark: jest.fn(),
  updateBookmark: jest.fn(),
  deleteBookmark: jest.fn(),
  createComment: jest.fn(),
  updateComment: jest.fn(),
  deleteComment: jest.fn(),
  createCallToAction: jest.fn(),
  updateCallToAction: jest.fn(),
  deleteCallToAction: jest.fn(),
  hasAutoGeneratedCTA: jest.fn(),
  getAutoGeneratedCTA: jest.fn(),
  getAnnotationCounts: jest.fn(),
};

// Mock the UserContext
const mockUserContext = {
  currentUser: { id: 'user1', name: 'Test User' },
  users: [],
  isLoading: false,
  error: null,
  loginUser: jest.fn(),
  switchUser: jest.fn(),
  updateCurrentUser: jest.fn(),
  removeUser: jest.fn(),
  logout: jest.fn(),
  clearError: jest.fn(),
};

jest.mock('./UserContext', () => ({
  useUser: () => mockUserContext,
  UserProvider: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
}));

// Test component that uses the annotation context
const TestComponent: React.FC = () => {
  const {
    annotations,
    isLoading,
    error,
    currentDocumentId,
    loadDocument,
    clearDocument,
    createHighlight,
    createBookmark,
    createComment,
    createCallToAction,
    hasAutoGeneratedCTA,
    getAutoGeneratedCTA,
    getAnnotationCounts,
    clearError,
  } = useAnnotations();

  const mockSelection: TextSelection = {
    text: 'Selected text',
    pageNumber: 1,
    startOffset: 0,
    endOffset: 13,
    coordinates: { x: 10, y: 20, width: 100, height: 20 }
  };

  const mockAreaCoordinates: AreaCoordinates = { x: 50, y: 100 };
  const mockRectCoordinates: RectangleCoordinates = { x: 50, y: 100, width: 200, height: 50 };

  return (
    <div>
      <div data-testid="loading">{isLoading.toString()}</div>
      <div data-testid="error">{error || 'no-error'}</div>
      <div data-testid="document-id">{currentDocumentId || 'no-document'}</div>
      <div data-testid="highlights-count">{annotations.highlights.length}</div>
      <div data-testid="bookmarks-count">{annotations.bookmarks.length}</div>
      <div data-testid="comments-count">{annotations.comments.length}</div>
      <div data-testid="ctas-count">{annotations.callToActions.length}</div>
      
      <button onClick={() => loadDocument('doc1')}>Load Document</button>
      <button onClick={clearDocument}>Clear Document</button>
      <button onClick={() => createHighlight(mockSelection)}>Create Highlight</button>
      <button onClick={() => createBookmark(1, 'Test Bookmark')}>Create Bookmark</button>
      <button onClick={() => createComment(1, 'Test comment', mockAreaCoordinates)}>Create Comment</button>
      <button onClick={() => createCallToAction(1, 'https://example.com', 'Test CTA', mockRectCoordinates, undefined)}>Create CTA</button>
      <button onClick={() => createCallToAction(1, 'http://test.com/qr', 'Auto CTA', mockRectCoordinates, { isAutoGenerated: true, qrCodeContent: 'qr-data' })}>Create Auto CTA</button>
      <button onClick={() => console.log(hasAutoGeneratedCTA('qr-data'))}>Check Auto CTA</button>
      <button onClick={() => console.log(getAutoGeneratedCTA('qr-data'))}>Get Auto CTA</button>
      <button onClick={clearError}>Clear Error</button>
    </div>
  );
};

describe('AnnotationContext', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    mockUserContext.currentUser = { id: 'user1', name: 'Test User' };
    
    // Setup default mock returns
    mockAnnotationManager.getAnnotations.mockReturnValue({
      highlights: [],
      bookmarks: [],
      comments: [],
      callToActions: []
    });
    
    mockAnnotationManager.getAnnotationCounts.mockReturnValue({
      highlights: 0,
      bookmarks: 0,
      comments: 0,
      callToActions: 0,
      total: 0
    });
  });

  it('should provide initial state', () => {
    render(
      <AnnotationProvider annotationManager={mockAnnotationManager as any}>
        <TestComponent />
      </AnnotationProvider>
    );

    expect(screen.getByTestId('loading')).toHaveTextContent('false');
    expect(screen.getByTestId('error')).toHaveTextContent('no-error');
    expect(screen.getByTestId('document-id')).toHaveTextContent('no-document');
    expect(screen.getByTestId('highlights-count')).toHaveTextContent('0');
    expect(screen.getByTestId('bookmarks-count')).toHaveTextContent('0');
    expect(screen.getByTestId('comments-count')).toHaveTextContent('0');
    expect(screen.getByTestId('ctas-count')).toHaveTextContent('0');
  });

  it('should load document annotations for current user', async () => {
    const user = userEvent.setup();
    const mockAnnotations = {
      highlights: [{ id: '1', userId: 'user1', documentId: 'doc1', pageNumber: 1, selectedText: 'test', color: '#ffff00', startOffset: 0, endOffset: 4, coordinates: { x: 0, y: 0, width: 50, height: 20 }, createdAt: new Date(), updatedAt: new Date() }],
      bookmarks: [{ id: '2', userId: 'user1', documentId: 'doc1', pageNumber: 1, title: 'Test Bookmark', createdAt: new Date(), updatedAt: new Date() }],
      comments: [],
      callToActions: []
    };

    mockAnnotationManager.getAnnotations.mockReturnValue(mockAnnotations);

    render(
      <AnnotationProvider annotationManager={mockAnnotationManager as any}>
        <TestComponent />
      </AnnotationProvider>
    );

    await act(async () => {
      await user.click(screen.getByText('Load Document'));
    });

    await waitFor(() => {
      expect(screen.getByTestId('document-id')).toHaveTextContent('doc1');
      expect(screen.getByTestId('highlights-count')).toHaveTextContent('1');
      expect(screen.getByTestId('bookmarks-count')).toHaveTextContent('1');
    });

    expect(mockAnnotationManager.getAnnotations).toHaveBeenCalledWith('user1', 'doc1');
  });

  it('should clear annotations when user changes', async () => {
    const mockAnnotations = {
      highlights: [{ id: '1', userId: 'user1', documentId: 'doc1', pageNumber: 1, selectedText: 'test', color: '#ffff00', startOffset: 0, endOffset: 4, coordinates: { x: 0, y: 0, width: 50, height: 20 }, createdAt: new Date(), updatedAt: new Date() }],
      bookmarks: [],
      comments: [],
      callToActions: []
    };

    mockAnnotationManager.getAnnotations.mockReturnValue(mockAnnotations);

    const { rerender } = render(
      <AnnotationProvider annotationManager={mockAnnotationManager as any}>
        <TestComponent />
      </AnnotationProvider>
    );

    // Load document first
    const user = userEvent.setup();
    await act(async () => {
      await user.click(screen.getByText('Load Document'));
    });

    await waitFor(() => {
      expect(screen.getByTestId('highlights-count')).toHaveTextContent('1');
    });

    // Change user
    mockUserContext.currentUser = null;
    
    rerender(
      <AnnotationProvider annotationManager={mockAnnotationManager as any}>
        <TestComponent />
      </AnnotationProvider>
    );

    await waitFor(() => {
      expect(screen.getByTestId('highlights-count')).toHaveTextContent('0');
      expect(screen.getByTestId('document-id')).toHaveTextContent('no-document');
    });
  });

  it('should create highlight with user isolation', async () => {
    const user = userEvent.setup();
    const mockHighlight = {
      id: 'highlight1',
      userId: 'user1',
      documentId: 'doc1',
      pageNumber: 1,
      selectedText: 'Selected text',
      color: '#ffff00',
      startOffset: 0,
      endOffset: 13,
      coordinates: { x: 10, y: 20, width: 100, height: 20 },
      createdAt: new Date(),
      updatedAt: new Date()
    };

    mockAnnotationManager.createHighlight.mockResolvedValue(mockHighlight);
    mockAnnotationManager.getAnnotations.mockReturnValue({
      highlights: [],
      bookmarks: [],
      comments: [],
      callToActions: []
    });

    render(
      <AnnotationProvider annotationManager={mockAnnotationManager as any}>
        <TestComponent />
      </AnnotationProvider>
    );

    // Load document first
    await act(async () => {
      await user.click(screen.getByText('Load Document'));
    });

    // Create highlight
    await act(async () => {
      await user.click(screen.getByText('Create Highlight'));
    });

    expect(mockAnnotationManager.createHighlight).toHaveBeenCalledWith(
      'user1',
      'doc1',
      expect.objectContaining({
        text: 'Selected text',
        pageNumber: 1,
        startOffset: 0,
        endOffset: 13
      }),
      '#ffff00'
    );
  });

  it('should create bookmark with user isolation', async () => {
    const user = userEvent.setup();
    const mockBookmark = {
      id: 'bookmark1',
      userId: 'user1',
      documentId: 'doc1',
      pageNumber: 1,
      title: 'Test Bookmark',
      createdAt: new Date(),
      updatedAt: new Date()
    };

    mockAnnotationManager.createBookmark.mockResolvedValue(mockBookmark);
    mockAnnotationManager.getAnnotations.mockReturnValue({
      highlights: [],
      bookmarks: [],
      comments: [],
      callToActions: []
    });

    render(
      <AnnotationProvider annotationManager={mockAnnotationManager as any}>
        <TestComponent />
      </AnnotationProvider>
    );

    // Load document first
    await act(async () => {
      await user.click(screen.getByText('Load Document'));
    });

    // Create bookmark
    await act(async () => {
      await user.click(screen.getByText('Create Bookmark'));
    });

    expect(mockAnnotationManager.createBookmark).toHaveBeenCalledWith(
      'user1',
      'doc1',
      1,
      'Test Bookmark',
      undefined
    );
  });

  it('should create comment with user isolation', async () => {
    const user = userEvent.setup();
    const mockComment = {
      id: 'comment1',
      userId: 'user1',
      documentId: 'doc1',
      pageNumber: 1,
      content: 'Test comment',
      coordinates: { x: 50, y: 100 },
      createdAt: new Date(),
      updatedAt: new Date()
    };

    mockAnnotationManager.createComment.mockResolvedValue(mockComment);
    mockAnnotationManager.getAnnotations.mockReturnValue({
      highlights: [],
      bookmarks: [],
      comments: [],
      callToActions: []
    });

    render(
      <AnnotationProvider annotationManager={mockAnnotationManager as any}>
        <TestComponent />
      </AnnotationProvider>
    );

    // Load document first
    await act(async () => {
      await user.click(screen.getByText('Load Document'));
    });

    // Create comment
    await act(async () => {
      await user.click(screen.getByText('Create Comment'));
    });

    expect(mockAnnotationManager.createComment).toHaveBeenCalledWith(
      'user1',
      'doc1',
      1,
      'Test comment',
      { x: 50, y: 100 }
    );
  });

  it('should create call-to-action with user isolation', async () => {
    const user = userEvent.setup();
    const mockCTA = {
      id: 'cta1',
      userId: 'user1',
      documentId: 'doc1',
      pageNumber: 1,
      url: 'https://example.com',
      label: 'Test CTA',
      coordinates: { x: 50, y: 100, width: 200, height: 50 },
      createdAt: new Date(),
      updatedAt: new Date()
    };

    mockAnnotationManager.createCallToAction.mockResolvedValue(mockCTA);
    mockAnnotationManager.getAnnotations.mockReturnValue({
      highlights: [],
      bookmarks: [],
      comments: [],
      callToActions: []
    });

    render(
      <AnnotationProvider annotationManager={mockAnnotationManager as any}>
        <TestComponent />
      </AnnotationProvider>
    );

    // Load document first
    await act(async () => {
      await user.click(screen.getByText('Load Document'));
    });

    // Create CTA
    await act(async () => {
      await user.click(screen.getByText('Create CTA'));
    });

    expect(mockAnnotationManager.createCallToAction).toHaveBeenCalledWith(
      'user1',
      'doc1',
      1,
      'https://example.com',
      'Test CTA',
      { x: 50, y: 100, width: 200, height: 50 },
      undefined,
      undefined
    );
  });

  it('should create auto-generated call-to-action with metadata', async () => {
    const user = userEvent.setup();
    const mockAutoCTA = {
      id: 'auto-cta1',
      userId: 'user1',
      documentId: 'doc1',
      pageNumber: 1,
      url: 'http://test.com/qr',
      label: 'Auto CTA',
      coordinates: { x: 50, y: 100, width: 200, height: 50 },
      isAutoGenerated: true,
      qrCodeContent: 'qr-data',
      autoGeneratedAt: new Date(),
      createdAt: new Date(),
      updatedAt: new Date()
    };

    mockAnnotationManager.createCallToAction.mockResolvedValue(mockAutoCTA);
    mockAnnotationManager.getAnnotations.mockReturnValue({
      highlights: [],
      bookmarks: [],
      comments: [],
      callToActions: []
    });

    render(
      <AnnotationProvider annotationManager={mockAnnotationManager as any}>
        <TestComponent />
      </AnnotationProvider>
    );

    // Load document first
    await act(async () => {
      await user.click(screen.getByText('Load Document'));
    });

    // Create auto-generated CTA
    await act(async () => {
      await user.click(screen.getByText('Create Auto CTA'));
    });

    expect(mockAnnotationManager.createCallToAction).toHaveBeenCalledWith(
      'user1',
      'doc1',
      1,
      'http://test.com/qr',
      'Auto CTA',
      { x: 50, y: 100, width: 200, height: 50 },
      true,
      'qr-data'
    );
  });

  it('should check for existing auto-generated CTAs', async () => {
    const user = userEvent.setup();
    const consoleSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
    
    mockAnnotationManager.hasAutoGeneratedCTA.mockReturnValue(true);
    mockAnnotationManager.getAutoGeneratedCTA.mockReturnValue({
      id: 'auto-cta1',
      userId: 'user1',
      documentId: 'doc1',
      pageNumber: 1,
      url: 'http://test.com/qr',
      label: 'Auto CTA',
      coordinates: { x: 50, y: 100, width: 200, height: 50 },
      isAutoGenerated: true,
      qrCodeContent: 'qr-data',
      autoGeneratedAt: new Date(),
      createdAt: new Date(),
      updatedAt: new Date()
    });

    mockAnnotationManager.getAnnotations.mockReturnValue({
      highlights: [],
      bookmarks: [],
      comments: [],
      callToActions: []
    });

    render(
      <AnnotationProvider annotationManager={mockAnnotationManager as any}>
        <TestComponent />
      </AnnotationProvider>
    );

    // Load document first
    await act(async () => {
      await user.click(screen.getByText('Load Document'));
    });

    // Check for auto-generated CTA
    await act(async () => {
      await user.click(screen.getByText('Check Auto CTA'));
    });

    expect(mockAnnotationManager.hasAutoGeneratedCTA).toHaveBeenCalledWith(
      'user1',
      'doc1',
      'qr-data',
      undefined
    );
    expect(consoleSpy).toHaveBeenCalledWith(true);

    // Get auto-generated CTA
    await act(async () => {
      await user.click(screen.getByText('Get Auto CTA'));
    });

    expect(mockAnnotationManager.getAutoGeneratedCTA).toHaveBeenCalledWith(
      'user1',
      'doc1',
      'qr-data',
      undefined
    );
    expect(consoleSpy).toHaveBeenCalledWith(expect.objectContaining({
      isAutoGenerated: true,
      qrCodeContent: 'qr-data'
    }));

    consoleSpy.mockRestore();
  });

  it('should handle errors when no user is logged in', async () => {
    const user = userEvent.setup();
    mockUserContext.currentUser = null;

    render(
      <AnnotationProvider annotationManager={mockAnnotationManager as any}>
        <TestComponent />
      </AnnotationProvider>
    );

    await act(async () => {
      await user.click(screen.getByText('Load Document'));
    });

    await waitFor(() => {
      expect(screen.getByTestId('error')).toHaveTextContent('No user logged in');
    });
  });

  it('should handle annotation manager errors', async () => {
    const user = userEvent.setup();
    mockAnnotationManager.getAnnotations.mockImplementation(() => {
      throw new Error('Storage error');
    });

    render(
      <AnnotationProvider annotationManager={mockAnnotationManager as any}>
        <TestComponent />
      </AnnotationProvider>
    );

    await act(async () => {
      await user.click(screen.getByText('Load Document'));
    });

    await waitFor(() => {
      expect(screen.getByTestId('error')).toHaveTextContent('Storage error');
    });
  });

  it('should clear errors', async () => {
    const user = userEvent.setup();
    mockAnnotationManager.getAnnotations.mockImplementation(() => {
      throw new Error('Storage error');
    });

    render(
      <AnnotationProvider annotationManager={mockAnnotationManager as any}>
        <TestComponent />
      </AnnotationProvider>
    );

    await act(async () => {
      await user.click(screen.getByText('Load Document'));
    });

    await waitFor(() => {
      expect(screen.getByTestId('error')).not.toHaveTextContent('no-error');
    });

    await act(async () => {
      await user.click(screen.getByText('Clear Error'));
    });

    await waitFor(() => {
      expect(screen.getByTestId('error')).toHaveTextContent('no-error');
    });
  });

  it('should throw error when useAnnotations is used outside provider', () => {
    const TestComponentOutsideProvider = () => {
      useAnnotations();
      return <div>Test</div>;
    };

    const consoleSpy = jest.spyOn(console, 'error').mockImplementation(() => {});

    expect(() => {
      render(<TestComponentOutsideProvider />);
    }).toThrow('useAnnotations must be used within an AnnotationProvider');

    consoleSpy.mockRestore();
  });
});