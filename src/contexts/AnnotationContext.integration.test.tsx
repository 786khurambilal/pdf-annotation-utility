import React from 'react';
import { render, screen, act, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { AnnotationProvider, useAnnotations } from './AnnotationContext';
import { UserProvider } from './UserContext';
import { AnnotationManager } from '../utils/AnnotationManager';
import { LocalStorageService } from '../utils/LocalStorageService';
import { CallToAction, RectangleCoordinates, UserAnnotations } from '../types/annotation.types';

// Mock the UserContext
const mockUserContext = {
  currentUser: { id: 'user1', name: 'Test User' },
  users: [],
  isLoading: false,
  error: null,
  loginUser: jest.fn(),
  switchUser: jest.fn(),
  updateCurrentUser: jest.fn(),
  removeUser: jest.fn(),
  logout: jest.fn(),
  clearError: jest.fn(),
};

jest.mock('./UserContext', () => ({
  useUser: () => mockUserContext,
  UserProvider: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
}));

// Mock AnnotationManager
const mockAnnotationManager = {
  getAnnotations: jest.fn(),
  createCallToAction: jest.fn(),
  updateCallToAction: jest.fn(),
  deleteCallToAction: jest.fn(),
  hasAutoGeneratedCTA: jest.fn(),
  getAutoGeneratedCTA: jest.fn(),
} as any;

// Test component for auto-generated CTA integration
const AutoCTATestComponent: React.FC = () => {
  const {
    annotations,
    currentDocumentId,
    loadDocument,
    createCallToAction,
    updateCallToAction,
    deleteCallToAction,
    hasAutoGeneratedCTA,
    getAutoGeneratedCTA,
    getCallToActionsByPage,
    error,
  } = useAnnotations();

  const mockCoordinates: RectangleCoordinates = { x: 100, y: 200, width: 150, height: 30 };

  return (
    <div>
      <div data-testid="document-id">{currentDocumentId || 'no-document'}</div>
      <div data-testid="error">{error || 'no-error'}</div>
      <div data-testid="total-ctas">{annotations.callToActions.length}</div>
      <div data-testid="auto-ctas">
        {annotations.callToActions.filter(cta => cta.isAutoGenerated).length}
      </div>
      <div data-testid="manual-ctas">
        {annotations.callToActions.filter(cta => !cta.isAutoGenerated).length}
      </div>
      
      <button onClick={() => loadDocument('test-doc')}>Load Document</button>
      
      <button 
        onClick={async () => {
          try {
            await createCallToAction(
              1, 
              'https://example.com/manual', 
              'Manual CTA', 
              mockCoordinates
            );
          } catch (err) {
            console.error('Failed to create manual CTA:', err);
          }
        }}
      >
        Create Manual CTA
      </button>
      
      <button 
        onClick={async () => {
          try {
            await createCallToAction(
              1, 
              'http://test.com/qr-content', 
              'QR Code Link - Page 1', 
              mockCoordinates,
              { isAutoGenerated: true, qrCodeContent: 'qr-content' }
            );
          } catch (err) {
            console.error('Failed to create auto CTA:', err);
          }
        }}
      >
        Create Auto CTA
      </button>
      
      <button 
        onClick={async () => {
          try {
            const autoCTA = annotations.callToActions.find(cta => cta.isAutoGenerated);
            if (autoCTA) {
              await updateCallToAction(autoCTA.id, { 
                url: 'https://updated.com', 
                label: 'Updated CTA' 
              });
            }
          } catch (err) {
            console.error('Failed to update auto CTA:', err);
          }
        }}
      >
        Update Auto CTA
      </button>
      
      <button 
        onClick={async () => {
          try {
            const autoCTA = annotations.callToActions.find(cta => cta.isAutoGenerated);
            if (autoCTA) {
              await deleteCallToAction(autoCTA.id);
            }
          } catch (err) {
            console.error('Failed to delete auto CTA:', err);
          }
        }}
      >
        Delete Auto CTA
      </button>
      
      <button 
        onClick={() => {
          const hasQR = hasAutoGeneratedCTA('qr-content', 1);
          const qrCTA = getAutoGeneratedCTA('qr-content', 1);
          console.log('Has QR CTA:', hasQR, 'QR CTA:', qrCTA);
        }}
      >
        Check QR CTA
      </button>
      
      <div data-testid="page-1-ctas">
        {getCallToActionsByPage(1).length}
      </div>
    </div>
  );
};

describe('AnnotationContext - Auto-Generated CTA Integration', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    mockUserContext.currentUser = { id: 'user1', name: 'Test User' };
    
    // Setup default mock returns
    mockAnnotationManager.getAnnotations.mockReturnValue({
      highlights: [],
      bookmarks: [],
      comments: [],
      callToActions: []
    });
  });

  it('should create and store auto-generated CTAs with metadata', async () => {
    const user = userEvent.setup();
    const mockAutoCTA: CallToAction = {
      id: 'auto-cta-1',
      userId: 'user1',
      documentId: 'test-doc',
      pageNumber: 1,
      url: 'http://test.com/qr-content',
      label: 'QR Code Link - Page 1',
      coordinates: { x: 100, y: 200, width: 150, height: 30 },
      isAutoGenerated: true,
      qrCodeContent: 'qr-content',
      autoGeneratedAt: new Date(),
      createdAt: new Date(),
      updatedAt: new Date()
    };

    mockAnnotationManager.createCallToAction.mockResolvedValue(mockAutoCTA);
    
    render(
      <AnnotationProvider annotationManager={mockAnnotationManager}>
        <AutoCTATestComponent />
      </AnnotationProvider>
    );

    // Load document
    await act(async () => {
      await user.click(screen.getByText('Load Document'));
    });

    // Create auto-generated CTA
    await act(async () => {
      await user.click(screen.getByText('Create Auto CTA'));
    });

    // Verify the annotation manager was called with correct parameters
    expect(mockAnnotationManager.createCallToAction).toHaveBeenCalledWith(
      'user1',
      'test-doc',
      1,
      'http://test.com/qr-content',
      'QR Code Link - Page 1',
      { x: 100, y: 200, width: 150, height: 30 },
      true,
      'qr-content'
    );
  });

  it('should create manual CTAs without auto-generation metadata', async () => {
    const user = userEvent.setup();
    const mockManualCTA: CallToAction = {
      id: 'manual-cta-1',
      userId: 'user1',
      documentId: 'test-doc',
      pageNumber: 1,
      url: 'https://example.com/manual',
      label: 'Manual CTA',
      coordinates: { x: 100, y: 200, width: 150, height: 30 },
      createdAt: new Date(),
      updatedAt: new Date()
    };

    mockAnnotationManager.createCallToAction.mockResolvedValue(mockManualCTA);
    
    render(
      <AnnotationProvider annotationManager={mockAnnotationManager}>
        <AutoCTATestComponent />
      </AnnotationProvider>
    );

    // Load document
    await act(async () => {
      await user.click(screen.getByText('Load Document'));
    });

    // Create manual CTA
    await act(async () => {
      await user.click(screen.getByText('Create Manual CTA'));
    });

    // Verify the annotation manager was called with correct parameters (no auto-generation metadata)
    expect(mockAnnotationManager.createCallToAction).toHaveBeenCalledWith(
      'user1',
      'test-doc',
      1,
      'https://example.com/manual',
      'Manual CTA',
      { x: 100, y: 200, width: 150, height: 30 },
      undefined,
      undefined
    );
  });

  it('should convert auto-generated CTA to manual when edited', async () => {
    const user = userEvent.setup();
    
    const mockAutoCTA: CallToAction = {
      id: 'auto-cta-1',
      userId: 'user1',
      documentId: 'test-doc',
      pageNumber: 1,
      url: 'http://test.com/qr-content',
      label: 'QR Code Link - Page 1',
      coordinates: { x: 100, y: 200, width: 150, height: 30 },
      isAutoGenerated: true,
      qrCodeContent: 'qr-content',
      autoGeneratedAt: new Date(),
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const mockUpdatedCTA: CallToAction = {
      ...mockAutoCTA,
      url: 'https://updated.com',
      label: 'Updated CTA',
      isAutoGenerated: false,
      qrCodeContent: undefined,
      autoGeneratedAt: undefined,
      updatedAt: new Date()
    };

    // Setup mocks - start with empty, then with created CTA
    let currentAnnotations = { highlights: [], bookmarks: [], comments: [], callToActions: [] as CallToAction[] };
    
    mockAnnotationManager.getAnnotations.mockImplementation(() => currentAnnotations);
    mockAnnotationManager.createCallToAction.mockImplementation(async () => {
      currentAnnotations.callToActions.push(mockAutoCTA);
      return mockAutoCTA;
    });
    mockAnnotationManager.updateCallToAction.mockImplementation(async () => {
      currentAnnotations.callToActions = [mockUpdatedCTA];
      return mockUpdatedCTA;
    });
    
    render(
      <AnnotationProvider annotationManager={mockAnnotationManager}>
        <AutoCTATestComponent />
      </AnnotationProvider>
    );

    // Load document and create auto CTA
    await act(async () => {
      await user.click(screen.getByText('Load Document'));
    });
    
    await act(async () => {
      await user.click(screen.getByText('Create Auto CTA'));
    });

    // Update the auto-generated CTA
    await act(async () => {
      await user.click(screen.getByText('Update Auto CTA'));
    });

    // Verify the update was called with correct parameters
    expect(mockAnnotationManager.updateCallToAction).toHaveBeenCalledWith(
      'user1',
      'test-doc',
      'auto-cta-1',
      { url: 'https://updated.com', label: 'Updated CTA' }
    );
  });

  it('should maintain user isolation for auto-generated CTAs', async () => {
    const user = userEvent.setup();
    
    // Mock existing CTA for user1
    const existingCTA: CallToAction = {
      id: 'existing-auto-cta',
      userId: 'user1',
      documentId: 'test-doc',
      pageNumber: 1,
      url: 'http://test.com/existing',
      label: 'Existing Auto CTA',
      coordinates: { x: 50, y: 50, width: 100, height: 25 },
      isAutoGenerated: true,
      qrCodeContent: 'existing-qr',
      autoGeneratedAt: new Date(),
      createdAt: new Date(),
      updatedAt: new Date()
    };

    // Setup mocks for user1
    mockAnnotationManager.getAnnotations.mockReturnValue({
      highlights: [],
      bookmarks: [],
      comments: [],
      callToActions: [existingCTA]
    });
    
    render(
      <AnnotationProvider annotationManager={mockAnnotationManager}>
        <AutoCTATestComponent />
      </AnnotationProvider>
    );

    // Load document for user1
    await act(async () => {
      await user.click(screen.getByText('Load Document'));
    });

    // Verify user1 sees their CTA
    expect(mockAnnotationManager.getAnnotations).toHaveBeenCalledWith('user1', 'test-doc');

    // Switch to user2
    mockUserContext.currentUser = { id: 'user2', name: 'User 2' };
    mockAnnotationManager.getAnnotations.mockReturnValue({
      highlights: [],
      bookmarks: [],
      comments: [],
      callToActions: []
    });

    // Reload document for user2
    await act(async () => {
      await user.click(screen.getByText('Load Document'));
    });

    // Verify user2 gets their own empty annotations
    expect(mockAnnotationManager.getAnnotations).toHaveBeenCalledWith('user2', 'test-doc');
  });

  it('should handle hasAutoGeneratedCTA and getAutoGeneratedCTA methods', async () => {
    const user = userEvent.setup();
    const consoleSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
    
    const mockAutoCTA: CallToAction = {
      id: 'auto-cta-1',
      userId: 'user1',
      documentId: 'test-doc',
      pageNumber: 1,
      url: 'http://test.com/qr-content',
      label: 'QR Code Link - Page 1',
      coordinates: { x: 100, y: 200, width: 150, height: 30 },
      isAutoGenerated: true,
      qrCodeContent: 'qr-content',
      autoGeneratedAt: new Date(),
      createdAt: new Date(),
      updatedAt: new Date()
    };

    // Setup mocks
    mockAnnotationManager.hasAutoGeneratedCTA.mockReturnValue(false);
    mockAnnotationManager.getAutoGeneratedCTA.mockReturnValue(null);
    
    render(
      <AnnotationProvider annotationManager={mockAnnotationManager}>
        <AutoCTATestComponent />
      </AnnotationProvider>
    );

    // Load document
    await act(async () => {
      await user.click(screen.getByText('Load Document'));
    });

    // Check for non-existent QR CTA
    await act(async () => {
      await user.click(screen.getByText('Check QR CTA'));
    });

    expect(mockAnnotationManager.hasAutoGeneratedCTA).toHaveBeenCalledWith('user1', 'test-doc', 'qr-content', 1);
    expect(mockAnnotationManager.getAutoGeneratedCTA).toHaveBeenCalledWith('user1', 'test-doc', 'qr-content', 1);
    expect(consoleSpy).toHaveBeenCalledWith('Has QR CTA:', false, 'QR CTA:', null);

    consoleSpy.mockRestore();
  });

  it('should handle deletion of auto-generated CTAs', async () => {
    const user = userEvent.setup();
    
    const mockAutoCTA: CallToAction = {
      id: 'auto-cta-1',
      userId: 'user1',
      documentId: 'test-doc',
      pageNumber: 1,
      url: 'http://test.com/qr-content',
      label: 'QR Code Link - Page 1',
      coordinates: { x: 100, y: 200, width: 150, height: 30 },
      isAutoGenerated: true,
      qrCodeContent: 'qr-content',
      autoGeneratedAt: new Date(),
      createdAt: new Date(),
      updatedAt: new Date()
    };

    // Setup mocks with stateful behavior
    let currentAnnotations = { highlights: [], bookmarks: [], comments: [], callToActions: [] as CallToAction[] };
    
    mockAnnotationManager.getAnnotations.mockImplementation(() => currentAnnotations);
    mockAnnotationManager.createCallToAction.mockImplementation(async () => {
      currentAnnotations.callToActions.push(mockAutoCTA);
      return mockAutoCTA;
    });
    mockAnnotationManager.deleteCallToAction.mockImplementation(async () => {
      currentAnnotations.callToActions = [];
    });
    
    render(
      <AnnotationProvider annotationManager={mockAnnotationManager}>
        <AutoCTATestComponent />
      </AnnotationProvider>
    );

    // Load document and create auto CTA
    await act(async () => {
      await user.click(screen.getByText('Load Document'));
    });
    
    await act(async () => {
      await user.click(screen.getByText('Create Auto CTA'));
    });

    // Delete the auto-generated CTA
    await act(async () => {
      await user.click(screen.getByText('Delete Auto CTA'));
    });

    // Verify deletion was called
    expect(mockAnnotationManager.deleteCallToAction).toHaveBeenCalledWith(
      'user1',
      'test-doc',
      'auto-cta-1'
    );
  });
});