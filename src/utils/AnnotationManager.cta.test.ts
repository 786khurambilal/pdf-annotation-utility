import { AnnotationManager } from './AnnotationManager';
import { LocalStorageService } from './LocalStorageService';
import { CallToAction } from '../types/annotation.types';

// Mock LocalStorageService
jest.mock('./LocalStorageService');

describe('AnnotationManager - CTA Management Features', () => {
  let annotationManager: AnnotationManager;
  let mockLocalStorage: jest.Mocked<LocalStorageService>;

  const mockManualCTA: CallToAction = {
    id: 'cta-1',
    userId: 'user-1',
    documentId: 'doc-1',
    pageNumber: 1,
    url: 'https://example.com',
    label: 'Example Link',
    coordinates: { x: 100, y: 100, width: 200, height: 50 },
    createdAt: new Date('2023-01-01'),
    updatedAt: new Date('2023-01-01'),
    isAutoGenerated: false
  };

  const mockAutoGeneratedCTA: CallToAction = {
    id: 'cta-2',
    userId: 'user-1',
    documentId: 'doc-1',
    pageNumber: 2,
    url: 'http://test.com/?qr=sample-qr-content',
    label: 'QR Code Link - Page 2',
    coordinates: { x: 150, y: 150, width: 100, height: 30 },
    createdAt: new Date('2023-01-02'),
    updatedAt: new Date('2023-01-02'),
    isAutoGenerated: true,
    qrCodeContent: 'sample-qr-content',
    autoGeneratedAt: new Date('2023-01-02')
  };

  beforeEach(() => {
    jest.clearAllMocks();
    mockLocalStorage = {
      getItem: jest.fn(),
      setItem: jest.fn(),
      removeItem: jest.fn(),
      clear: jest.fn(),
      loadAnnotations: jest.fn(),
      saveAnnotations: jest.fn(),
    } as any;

    (LocalStorageService.getInstance as jest.Mock).mockReturnValue(mockLocalStorage);
    annotationManager = new AnnotationManager(mockLocalStorage);
  });

  describe('Auto-Generated CTA Status Change', () => {
    beforeEach(() => {
      // Mock existing annotations
      mockLocalStorage.loadAnnotations.mockReturnValue({
        highlights: [],
        bookmarks: [],
        comments: [],
        callToActions: [mockAutoGeneratedCTA]
      });
    });

    it('should convert auto-generated CTA to manual when URL is updated', () => {
      const updatedCTA = annotationManager.updateCallToAction(
        'user-1',
        'doc-1',
        'cta-2',
        { url: 'https://custom.com', label: 'QR Code Link - Page 2' }
      );

      expect(updatedCTA.isAutoGenerated).toBe(false);
      expect(updatedCTA.qrCodeContent).toBeUndefined();
      expect(updatedCTA.autoGeneratedAt).toBeUndefined();
      expect(updatedCTA.url).toBe('https://custom.com');
      expect(updatedCTA.updatedAt).toBeInstanceOf(Date);
    });

    it('should convert auto-generated CTA to manual when label is updated', () => {
      const updatedCTA = annotationManager.updateCallToAction(
        'user-1',
        'doc-1',
        'cta-2',
        { url: 'http://test.com/?qr=sample-qr-content', label: 'Custom Label' }
      );

      expect(updatedCTA.isAutoGenerated).toBe(false);
      expect(updatedCTA.qrCodeContent).toBeUndefined();
      expect(updatedCTA.autoGeneratedAt).toBeUndefined();
      expect(updatedCTA.label).toBe('Custom Label');
    });

    it('should convert auto-generated CTA to manual when both URL and label are updated', () => {
      const updatedCTA = annotationManager.updateCallToAction(
        'user-1',
        'doc-1',
        'cta-2',
        { url: 'https://new.com', label: 'New Label' }
      );

      expect(updatedCTA.isAutoGenerated).toBe(false);
      expect(updatedCTA.qrCodeContent).toBeUndefined();
      expect(updatedCTA.autoGeneratedAt).toBeUndefined();
      expect(updatedCTA.url).toBe('https://new.com');
      expect(updatedCTA.label).toBe('New Label');
    });

    it('should not affect manual CTAs when updated', () => {
      // Mock manual CTA in storage
      mockLocalStorage.loadAnnotations.mockReturnValue({
        highlights: [],
        bookmarks: [],
        comments: [],
        callToActions: [mockManualCTA]
      });

      const updatedCTA = annotationManager.updateCallToAction(
        'user-1',
        'doc-1',
        'cta-1',
        { url: 'https://updated.com', label: 'Updated Label' }
      );

      expect(updatedCTA.isAutoGenerated).toBe(false);
      expect(updatedCTA.qrCodeContent).toBeUndefined();
      expect(updatedCTA.autoGeneratedAt).toBeUndefined();
      expect(updatedCTA.url).toBe('https://updated.com');
      expect(updatedCTA.label).toBe('Updated Label');
    });

    it('should save updated CTA to storage', () => {
      annotationManager.updateCallToAction(
        'user-1',
        'doc-1',
        'cta-2',
        { url: 'https://custom.com', label: 'Custom Label' }
      );

      expect(mockLocalStorage.saveAnnotations).toHaveBeenCalledWith(
        'user-1',
        'doc-1',
        expect.objectContaining({
          callToActions: expect.arrayContaining([
            expect.objectContaining({
              isAutoGenerated: false
            })
          ])
        })
      );
    });
  });

  describe('Auto-Generated CTA Duplication Prevention', () => {
    beforeEach(() => {
      mockLocalStorage.loadAnnotations.mockReturnValue({
        highlights: [],
        bookmarks: [],
        comments: [],
        callToActions: [mockAutoGeneratedCTA]
      });
    });

    it('should detect existing auto-generated CTA by QR content', () => {
      const exists = annotationManager.hasAutoGeneratedCTA(
        'user-1',
        'doc-1',
        'sample-qr-content'
      );

      expect(exists).toBe(true);
    });

    it('should detect existing auto-generated CTA by QR content and page', () => {
      const exists = annotationManager.hasAutoGeneratedCTA(
        'user-1',
        'doc-1',
        'sample-qr-content',
        2
      );

      expect(exists).toBe(true);
    });

    it('should not detect auto-generated CTA on different page', () => {
      const exists = annotationManager.hasAutoGeneratedCTA(
        'user-1',
        'doc-1',
        'sample-qr-content',
        3
      );

      expect(exists).toBe(false);
    });

    it('should not detect non-existent QR content', () => {
      const exists = annotationManager.hasAutoGeneratedCTA(
        'user-1',
        'doc-1',
        'non-existent-content'
      );

      expect(exists).toBe(false);
    });

    it('should return false for manual CTAs with same content', () => {
      const manualCTAWithQRContent: CallToAction = {
        ...mockManualCTA,
        qrCodeContent: 'sample-qr-content',
        isAutoGenerated: false
      };

      mockLocalStorage.loadAnnotations.mockReturnValue({
        highlights: [],
        bookmarks: [],
        comments: [],
        callToActions: [manualCTAWithQRContent]
      });

      const exists = annotationManager.hasAutoGeneratedCTA(
        'user-1',
        'doc-1',
        'sample-qr-content'
      );

      expect(exists).toBe(false);
    });

    it('should get existing auto-generated CTA by QR content', () => {
      const cta = annotationManager.getAutoGeneratedCTA(
        'user-1',
        'doc-1',
        'sample-qr-content'
      );

      expect(cta).toEqual(mockAutoGeneratedCTA);
    });

    it('should get existing auto-generated CTA by QR content and page', () => {
      const cta = annotationManager.getAutoGeneratedCTA(
        'user-1',
        'doc-1',
        'sample-qr-content',
        2
      );

      expect(cta).toEqual(mockAutoGeneratedCTA);
    });

    it('should return null for non-existent auto-generated CTA', () => {
      const cta = annotationManager.getAutoGeneratedCTA(
        'user-1',
        'doc-1',
        'non-existent-content'
      );

      expect(cta).toBeNull();
    });

    it('should return null when searching different page', () => {
      const cta = annotationManager.getAutoGeneratedCTA(
        'user-1',
        'doc-1',
        'sample-qr-content',
        3
      );

      expect(cta).toBeNull();
    });
  });

  describe('Auto-Generated CTA Deletion', () => {
    beforeEach(() => {
      mockLocalStorage.loadAnnotations.mockReturnValue({
        highlights: [],
        bookmarks: [],
        comments: [],
        callToActions: [mockAutoGeneratedCTA, mockManualCTA]
      });
    });

    it('should delete auto-generated CTA', () => {
      annotationManager.deleteCallToAction('user-1', 'doc-1', 'cta-2');

      expect(mockLocalStorage.saveAnnotations).toHaveBeenCalledWith(
        'user-1',
        'doc-1',
        expect.objectContaining({
          callToActions: expect.arrayContaining([
            expect.objectContaining({ id: 'cta-1' })
          ])
        })
      );
    });

    it('should delete manual CTA', () => {
      annotationManager.deleteCallToAction('user-1', 'doc-1', 'cta-1');

      expect(mockLocalStorage.saveAnnotations).toHaveBeenCalledWith(
        'user-1',
        'doc-1',
        expect.objectContaining({
          callToActions: expect.arrayContaining([
            expect.objectContaining({ id: 'cta-2' })
          ])
        })
      );
    });

    it('should throw error when deleting non-existent CTA', () => {
      expect(() => {
        annotationManager.deleteCallToAction('user-1', 'doc-1', 'non-existent');
      }).toThrow('Call-to-action with ID non-existent not found');
    });
  });

  describe('Error Handling', () => {
    it('should handle invalid parameters for hasAutoGeneratedCTA', () => {
      expect(annotationManager.hasAutoGeneratedCTA('', 'doc-1', 'content')).toBe(false);
      expect(annotationManager.hasAutoGeneratedCTA('user-1', '', 'content')).toBe(false);
      expect(annotationManager.hasAutoGeneratedCTA('user-1', 'doc-1', '')).toBe(false);
    });

    it('should handle invalid parameters for getAutoGeneratedCTA', () => {
      expect(annotationManager.getAutoGeneratedCTA('', 'doc-1', 'content')).toBeNull();
      expect(annotationManager.getAutoGeneratedCTA('user-1', '', 'content')).toBeNull();
      expect(annotationManager.getAutoGeneratedCTA('user-1', 'doc-1', '')).toBeNull();
    });

    it('should handle corrupted storage data', () => {
      mockLocalStorage.loadAnnotations.mockImplementation(() => {
        throw new Error('Invalid data');
      });

      const exists = annotationManager.hasAutoGeneratedCTA(
        'user-1',
        'doc-1',
        'sample-qr-content'
      );

      expect(exists).toBe(false);
    });

    it('should handle missing callToActions array in storage', () => {
      mockLocalStorage.loadAnnotations.mockReturnValue({
        highlights: [],
        bookmarks: [],
        comments: []
        // Missing callToActions
      });

      const exists = annotationManager.hasAutoGeneratedCTA(
        'user-1',
        'doc-1',
        'sample-qr-content'
      );

      expect(exists).toBe(false);
    });
  });

  describe('Multiple Auto-Generated CTAs', () => {
    const mockAutoGeneratedCTA2: CallToAction = {
      id: 'cta-3',
      userId: 'user-1',
      documentId: 'doc-1',
      pageNumber: 3,
      url: 'http://test.com/?qr=another-qr-content',
      label: 'Another QR Link',
      coordinates: { x: 200, y: 200, width: 100, height: 30 },
      createdAt: new Date('2023-01-03'),
      updatedAt: new Date('2023-01-03'),
      isAutoGenerated: true,
      qrCodeContent: 'another-qr-content',
      autoGeneratedAt: new Date('2023-01-03')
    };

    beforeEach(() => {
      mockLocalStorage.loadAnnotations.mockReturnValue({
        highlights: [],
        bookmarks: [],
        comments: [],
        callToActions: [mockAutoGeneratedCTA, mockAutoGeneratedCTA2, mockManualCTA]
      });
    });

    it('should detect correct auto-generated CTA by content', () => {
      const exists1 = annotationManager.hasAutoGeneratedCTA(
        'user-1',
        'doc-1',
        'sample-qr-content'
      );
      const exists2 = annotationManager.hasAutoGeneratedCTA(
        'user-1',
        'doc-1',
        'another-qr-content'
      );

      expect(exists1).toBe(true);
      expect(exists2).toBe(true);
    });

    it('should get correct auto-generated CTA by content', () => {
      const cta1 = annotationManager.getAutoGeneratedCTA(
        'user-1',
        'doc-1',
        'sample-qr-content'
      );
      const cta2 = annotationManager.getAutoGeneratedCTA(
        'user-1',
        'doc-1',
        'another-qr-content'
      );

      expect(cta1?.id).toBe('cta-2');
      expect(cta2?.id).toBe('cta-3');
    });

    it('should update only the correct auto-generated CTA', () => {
      const updatedCTA = annotationManager.updateCallToAction(
        'user-1',
        'doc-1',
        'cta-2',
        { url: 'https://custom.com', label: 'Custom Label' }
      );

      expect(updatedCTA.isAutoGenerated).toBe(false);

      // Check that the other auto-generated CTA is unchanged
      const otherCTA = annotationManager.getAutoGeneratedCTA(
        'user-1',
        'doc-1',
        'another-qr-content'
      );
      expect(otherCTA?.isAutoGenerated).toBe(true);
    });
  });
});