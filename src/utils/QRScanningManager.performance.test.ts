import { QRScanningManager, QRScanningConfig } from './QRScanningManager';
import { QRCodeScanner, QRCodeScanResult } from './QRCodeScanner';
import { PageContentExtractor } from './PageContentExtractor';
import { AutoCTAGenerator } from './AutoCTAGenerator';
import { CallToAction } from '../types/annotation.types';

// Mock implementations for testing
class MockQRCodeScanner implements QRCodeScanner {
  private scanDelay: number;
  private shouldFail: boolean;
  private qrCodesPerPage: number;

  constructor(scanDelay = 100, shouldFail = false, qrCodesPerPage = 1) {
    this.scanDelay = scanDelay;
    this.shouldFail = shouldFail;
    this.qrCodesPerPage = qrCodesPerPage;
  }

  isQRCodeDetectionSupported(): boolean {
    return true;
  }

  async scanPage(pageCanvas: HTMLCanvasElement): Promise<QRCodeScanResult[]> {
    // Simulate processing time
    await new Promise(resolve => setTimeout(resolve, this.scanDelay));

    if (this.shouldFail) {
      throw new Error('Mock scan failure');
    }

    // Generate mock QR codes
    const results: QRCodeScanResult[] = [];
    for (let i = 0; i < this.qrCodesPerPage; i++) {
      results.push({
        content: `https://example.com/qr-${i}`,
        coordinates: { x: 100 + i * 50, y: 100, width: 50, height: 50 },
        confidence: 0.9
      });
    }

    return results;
  }

  setScanDelay(delay: number): void {
    this.scanDelay = delay;
  }

  setShouldFail(shouldFail: boolean): void {
    this.shouldFail = shouldFail;
  }

  setQRCodesPerPage(count: number): void {
    this.qrCodesPerPage = count;
  }
}

class MockPageContentExtractor implements PageContentExtractor {
  async extractHeadings(): Promise<any[]> {
    return [{ text: 'Test Heading', level: 1, coordinates: { x: 0, y: 0, width: 100, height: 20 } }];
  }

  findBestHeadingForArea(): string | null {
    return 'Test Heading';
  }
}

class MockAutoCTAGenerator implements AutoCTAGenerator {
  createFromQRCode(
    qrResult: QRCodeScanResult,
    pageNumber: number,
    pageHeading: string | null,
    userId: string,
    documentId: string
  ): CallToAction {
    return {
      id: `cta-${Date.now()}-${Math.random()}`,
      type: 'cta',
      userId,
      documentId,
      pageNumber,
      coordinates: qrResult.coordinates,
      createdAt: new Date(),
      updatedAt: new Date(),
      url: qrResult.content,
      label: pageHeading || `QR Code Link - Page ${pageNumber}`,
      isAutoGenerated: true,
      qrCodeContent: qrResult.content,
      autoGeneratedAt: new Date()
    };
  }
}

// Helper function to create mock canvas
function createMockCanvas(width = 800, height = 600): HTMLCanvasElement {
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  return canvas;
}

describe('QRScanningManager Performance Tests', () => {
  let mockScanner: MockQRCodeScanner;
  let mockExtractor: MockPageContentExtractor;
  let mockGenerator: MockAutoCTAGenerator;
  let scanningManager: QRScanningManager;

  beforeEach(() => {
    mockScanner = new MockQRCodeScanner();
    mockExtractor = new MockPageContentExtractor();
    mockGenerator = new MockAutoCTAGenerator();
  });

  afterEach(() => {
    if (scanningManager) {
      scanningManager.dispose();
    }
  });

  describe('Memory Management', () => {
    test('should handle large number of pages without memory leaks', async () => {
      const config: QRScanningConfig = {
        pageTimeoutMs: 1000,
        maxRetries: 1,
        maxConcurrentPages: 2,
        memoryThresholdMB: 50,
        maxQRCodesPerDocument: 1000,
        performanceMonitoring: true
      };

      scanningManager = new QRScanningManager(mockScanner, mockExtractor, mockGenerator, config);
      
      const totalPages = 10; // Reduced for faster testing
      const getPageCanvas = jest.fn().mockImplementation(() => 
        Promise.resolve(createMockCanvas())
      );

      // Monitor memory usage during scanning
      const initialMemory = (performance as any).memory?.usedJSHeapSize || 0;
      
      const results = await scanningManager.startScanning(
        'test-doc',
        totalPages,
        getPageCanvas,
        'test-user'
      );

      const finalMemory = (performance as any).memory?.usedJSHeapSize || 0;
      const memoryIncrease = (finalMemory - initialMemory) / (1024 * 1024); // MB

      expect(results).toBeDefined();
      expect(getPageCanvas).toHaveBeenCalledTimes(totalPages);
      
      // Memory increase should be reasonable (less than 100MB for 10 pages)
      if (initialMemory > 0) {
        expect(memoryIncrease).toBeLessThan(100);
      }

      const state = scanningManager.getState();
      expect(state.performanceMetrics).toBeDefined();
      expect(typeof state.performanceMetrics?.memoryUsage).toBe('number');
    }, 30000);

    test('should cleanup resources when scanning is stopped', async () => {
      scanningManager = new QRScanningManager(mockScanner, mockExtractor, mockGenerator);
      
      const getPageCanvas = jest.fn().mockImplementation(() => 
        Promise.resolve(createMockCanvas())
      );

      // Start scanning
      const scanPromise = scanningManager.startScanning('test-doc', 50, getPageCanvas, 'test-user');
      
      // Stop after a few pages
      setTimeout(() => {
        scanningManager.stopScanning();
      }, 500);

      await expect(scanPromise).resolves.toBeDefined();
      
      const state = scanningManager.getState();
      expect(state.isScanning).toBe(false);
    });

    test('should handle memory threshold exceeded', async () => {
      const config: QRScanningConfig = {
        pageTimeoutMs: 1000,
        maxRetries: 1,
        maxConcurrentPages: 1,
        memoryThresholdMB: 1, // Very low threshold to trigger cleanup
        maxQRCodesPerDocument: 100,
        performanceMonitoring: true
      };

      scanningManager = new QRScanningManager(mockScanner, mockExtractor, mockGenerator, config);
      
      const getPageCanvas = jest.fn().mockImplementation(() => 
        Promise.resolve(createMockCanvas(2000, 2000)) // Large canvas
      );

      const results = await scanningManager.startScanning('test-doc', 10, getPageCanvas, 'test-user');
      
      expect(results).toBeDefined();
      const state = scanningManager.getState();
      expect(state.errors.length).toBeGreaterThan(0);
    });
  });

  describe('Timeout Handling', () => {
    test('should timeout slow page scans', async () => {
      mockScanner.setScanDelay(3000); // 3 seconds, longer than timeout
      
      const config: QRScanningConfig = {
        pageTimeoutMs: 1000, // 1 second timeout
        maxRetries: 0,
        maxConcurrentPages: 1,
        memoryThresholdMB: 100,
        maxQRCodesPerDocument: 100,
        performanceMonitoring: true
      };

      scanningManager = new QRScanningManager(mockScanner, mockExtractor, mockGenerator, config);
      
      const getPageCanvas = jest.fn().mockImplementation(() => 
        Promise.resolve(createMockCanvas())
      );

      const results = await scanningManager.startScanning('test-doc', 2, getPageCanvas, 'test-user');
      
      const state = scanningManager.getState();
      expect(state.errors.length).toBeGreaterThan(0);
      expect(state.errors.some(error => error.error.includes('timeout'))).toBe(true);
      expect(state.performanceMetrics?.timeoutCount).toBeGreaterThan(0);
    }, 15000);

    test('should handle mixed timeout and success scenarios', async () => {
      let callCount = 0;
      const originalScanPage = mockScanner.scanPage.bind(mockScanner);
      
      mockScanner.scanPage = jest.fn().mockImplementation(async (canvas) => {
        callCount++;
        // Make every other call slow
        if (callCount % 2 === 0) {
          mockScanner.setScanDelay(3000);
        } else {
          mockScanner.setScanDelay(100);
        }
        return originalScanPage(canvas);
      });

      const config: QRScanningConfig = {
        pageTimeoutMs: 1000,
        maxRetries: 0,
        maxConcurrentPages: 1,
        memoryThresholdMB: 100,
        maxQRCodesPerDocument: 100,
        performanceMonitoring: true
      };

      scanningManager = new QRScanningManager(mockScanner, mockExtractor, mockGenerator, config);
      
      const getPageCanvas = jest.fn().mockImplementation(() => 
        Promise.resolve(createMockCanvas())
      );

      const results = await scanningManager.startScanning('test-doc', 6, getPageCanvas, 'test-user');
      
      const state = scanningManager.getState();
      expect(results.length).toBeGreaterThan(0); // Some should succeed
      expect(state.errors.length).toBeGreaterThan(0); // Some should timeout
      expect(state.performanceMetrics?.timeoutCount).toBeGreaterThan(0);
    }, 20000);
  });

  describe('Error Recovery', () => {
    test('should retry failed page scans', async () => {
      let attemptCount = 0;
      const originalScanPage = mockScanner.scanPage.bind(mockScanner);
      
      mockScanner.scanPage = jest.fn().mockImplementation(async (canvas) => {
        attemptCount++;
        // Fail first two attempts, succeed on third
        if (attemptCount <= 2) {
          throw new Error('Mock failure');
        }
        return originalScanPage(canvas);
      });

      const config: QRScanningConfig = {
        pageTimeoutMs: 5000,
        maxRetries: 3,
        maxConcurrentPages: 1,
        memoryThresholdMB: 100,
        maxQRCodesPerDocument: 100,
        performanceMonitoring: true
      };

      scanningManager = new QRScanningManager(mockScanner, mockExtractor, mockGenerator, config);
      
      const getPageCanvas = jest.fn().mockImplementation(() => 
        Promise.resolve(createMockCanvas())
      );

      const results = await scanningManager.startScanning('test-doc', 1, getPageCanvas, 'test-user');
      
      expect(results.length).toBeGreaterThanOrEqual(0); // May succeed after retries
      expect(attemptCount).toBeGreaterThan(1); // Should have retried at least once
      
      const state = scanningManager.getState();
      expect(state.performanceMetrics?.retryCount).toBeGreaterThanOrEqual(0);
    }, 15000);

    test('should give up after max retries', async () => {
      mockScanner.setShouldFail(true);

      const config: QRScanningConfig = {
        pageTimeoutMs: 5000,
        maxRetries: 2,
        maxConcurrentPages: 1,
        memoryThresholdMB: 100,
        maxQRCodesPerDocument: 100,
        performanceMonitoring: true
      };

      scanningManager = new QRScanningManager(mockScanner, mockExtractor, mockGenerator, config);
      
      const getPageCanvas = jest.fn().mockImplementation(() => 
        Promise.resolve(createMockCanvas())
      );

      const results = await scanningManager.startScanning('test-doc', 1, getPageCanvas, 'test-user');
      
      expect(results.length).toBe(0); // Should fail completely
      
      const state = scanningManager.getState();
      expect(state.errors.length).toBe(1);
      expect(state.performanceMetrics?.retryCount).toBe(2);
    }, 15000);
  });

  describe('Performance Monitoring', () => {
    test('should track performance metrics', async () => {
      const config: QRScanningConfig = {
        pageTimeoutMs: 5000,
        maxRetries: 1,
        maxConcurrentPages: 1,
        memoryThresholdMB: 100,
        maxQRCodesPerDocument: 100,
        performanceMonitoring: true
      };

      scanningManager = new QRScanningManager(mockScanner, mockExtractor, mockGenerator, config);
      
      const getPageCanvas = jest.fn().mockImplementation(() => 
        Promise.resolve(createMockCanvas())
      );

      const results = await scanningManager.startScanning('test-doc', 5, getPageCanvas, 'test-user');
      
      const state = scanningManager.getState();
      expect(state.performanceMetrics).toBeDefined();
      expect(state.performanceMetrics?.averagePageScanTime).toBeGreaterThan(0);
      expect(typeof state.performanceMetrics?.memoryUsage).toBe('number');
      expect(typeof state.performanceMetrics?.timeoutCount).toBe('number');
      expect(typeof state.performanceMetrics?.retryCount).toBe('number');
    });

    test('should handle performance monitoring disabled', async () => {
      const config: QRScanningConfig = {
        pageTimeoutMs: 5000,
        maxRetries: 1,
        maxConcurrentPages: 1,
        memoryThresholdMB: 100,
        maxQRCodesPerDocument: 100,
        performanceMonitoring: false
      };

      scanningManager = new QRScanningManager(mockScanner, mockExtractor, mockGenerator, config);
      
      const getPageCanvas = jest.fn().mockImplementation(() => 
        Promise.resolve(createMockCanvas())
      );

      const results = await scanningManager.startScanning('test-doc', 3, getPageCanvas, 'test-user');
      
      expect(results).toBeDefined();
      const state = scanningManager.getState();
      expect(state.performanceMetrics).toBeDefined(); // Still defined but may not be actively updated
    });
  });

  describe('Scanning Limits', () => {
    test('should respect max QR codes per document limit', async () => {
      mockScanner.setQRCodesPerPage(10); // Many QR codes per page

      const config: QRScanningConfig = {
        pageTimeoutMs: 5000,
        maxRetries: 1,
        maxConcurrentPages: 1,
        memoryThresholdMB: 100,
        maxQRCodesPerDocument: 25, // Limit to 25 QR codes
        performanceMonitoring: true
      };

      scanningManager = new QRScanningManager(mockScanner, mockExtractor, mockGenerator, config);
      
      const getPageCanvas = jest.fn().mockImplementation(() => 
        Promise.resolve(createMockCanvas())
      );

      const results = await scanningManager.startScanning('test-doc', 10, getPageCanvas, 'test-user');
      
      const state = scanningManager.getState();
      expect(state.foundQRCodes).toBeLessThanOrEqual(25);
      expect(state.errors.some(error => error.error.includes('Maximum QR codes'))).toBe(true);
    });

    test('should handle large PDFs efficiently', async () => {
      const config: QRScanningConfig = {
        pageTimeoutMs: 1000,
        maxRetries: 1,
        maxConcurrentPages: 2,
        memoryThresholdMB: 100,
        maxQRCodesPerDocument: 500,
        performanceMonitoring: true
      };

      scanningManager = new QRScanningManager(mockScanner, mockExtractor, mockGenerator, config);
      
      const totalPages = 20; // Reduced for faster testing
      const getPageCanvas = jest.fn().mockImplementation(() => 
        Promise.resolve(createMockCanvas())
      );

      const startTime = Date.now();
      const results = await scanningManager.startScanning('test-doc', totalPages, getPageCanvas, 'test-user');
      const endTime = Date.now();
      
      const totalTime = endTime - startTime;
      const averageTimePerPage = totalTime / totalPages;
      
      expect(results).toBeDefined();
      expect(getPageCanvas).toHaveBeenCalledTimes(totalPages);
      expect(averageTimePerPage).toBeLessThan(2000); // Should be efficient
      
      const state = scanningManager.getState();
      expect(state.performanceMetrics).toBeDefined();
    }, 60000);
  });

  describe('Resource Cleanup', () => {
    test('should dispose resources properly', () => {
      scanningManager = new QRScanningManager(mockScanner, mockExtractor, mockGenerator);
      
      const stateCallback = jest.fn();
      const progressCallback = jest.fn();
      
      const unsubscribeState = scanningManager.onStateChange(stateCallback);
      const unsubscribeProgress = scanningManager.onProgress(progressCallback);
      
      expect(typeof unsubscribeState).toBe('function');
      expect(typeof unsubscribeProgress).toBe('function');
      
      scanningManager.dispose();
      
      // Should not throw after disposal
      expect(() => scanningManager.getState()).not.toThrow();
      expect(() => scanningManager.getCurrentProgress()).not.toThrow();
    });

    test('should cleanup after reset', async () => {
      scanningManager = new QRScanningManager(mockScanner, mockExtractor, mockGenerator);
      
      const getPageCanvas = jest.fn().mockImplementation(() => 
        Promise.resolve(createMockCanvas())
      );

      // Start scanning
      const scanPromise = scanningManager.startScanning('test-doc', 10, getPageCanvas, 'test-user');
      
      // Reset while scanning
      setTimeout(() => {
        scanningManager.reset();
      }, 200);

      await expect(scanPromise).resolves.toBeDefined();
      
      const state = scanningManager.getState();
      expect(state.isScanning).toBe(false);
      expect(state.currentPage).toBe(0);
      expect(state.foundQRCodes).toBe(0);
      expect(state.errors).toHaveLength(0);
    });
  });
});