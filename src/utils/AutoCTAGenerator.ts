import { CallToAction, createCallToAction, RectangleCoordinates } from '../types/annotation.types';
import { QRCodeScanResult } from './QRCodeScanner';
import { PageHeading } from './PageContentExtractor';
import { AnnotationManager } from './AnnotationManager';

/**
 * Configuration interface for AutoCTAGenerator
 */
export interface AutoCTAConfig {
  baseUrl: string; // Default: "http://test.com/"
  maxTitleLength: number; // Default: 50 characters
  defaultTitleTemplate: string; // Default: "QR Code Link - Page {pageNumber}"
}

/**
 * Default configuration for AutoCTAGenerator
 */
const DEFAULT_CONFIG: AutoCTAConfig = {
  baseUrl: 'http://test.com/',
  maxTitleLength: 50,
  defaultTitleTemplate: 'QR Code Link - Page {pageNumber}'
};

/**
 * Factory class for creating auto-generated Call-to-Action annotations from QR codes
 */
export class AutoCTAGenerator {
  private config: AutoCTAConfig;

  constructor(config: Partial<AutoCTAConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  /**
   * Create a CallToAction from QR code scan result
   * @param qrResult - QR code scan result containing content and coordinates
   * @param pageNumber - Page number where QR code was found
   * @param pageHeading - Best heading found near QR code (can be null)
   * @param userId - User ID for the annotation
   * @param documentId - Document ID for the annotation
   * @param annotationManager - Optional annotation manager for duplication checking
   * @returns Auto-generated CallToAction annotation or null if duplicate exists
   */
  createFromQRCode(
    qrResult: QRCodeScanResult,
    pageNumber: number,
    pageHeading: string | null,
    userId: string,
    documentId: string,
    annotationManager?: AnnotationManager
  ): CallToAction | null {
    // Check for existing auto-generated CTA with same QR content if annotation manager provided
    if (annotationManager && annotationManager.hasAutoGeneratedCTA(userId, documentId, qrResult.content, pageNumber)) {
      return null; // Skip creating duplicate
    }
    
    // Generate unique ID for the CTA
    const id = this.generateCTAId(qrResult, pageNumber, documentId);
    
    // Generate URL from QR code content
    const url = this.generateURL(qrResult.content);
    
    // Generate title from page heading or fallback
    const label = this.generateTitle(pageHeading, pageNumber);
    
    // Create the CallToAction using the existing helper
    return createCallToAction(
      id,
      userId,
      documentId,
      pageNumber,
      url,
      label,
      qrResult.coordinates,
      true, // isAutoGenerated
      qrResult.content // qrCodeContent
    );
  }

  /**
   * Create multiple CTAs from an array of QR code results
   * @param qrResults - Array of QR code scan results
   * @param pageNumber - Page number where QR codes were found
   * @param headings - Array of headings found on the page
   * @param userId - User ID for the annotations
   * @param documentId - Document ID for the annotations
   * @param findBestHeading - Function to find best heading for QR code area
   * @param annotationManager - Optional annotation manager for duplication checking
   * @returns Array of auto-generated CallToAction annotations (excluding duplicates)
   */
  createMultipleFromQRCodes(
    qrResults: QRCodeScanResult[],
    pageNumber: number,
    headings: PageHeading[],
    userId: string,
    documentId: string,
    findBestHeading: (headings: PageHeading[], qrCoordinates: RectangleCoordinates) => string | null,
    annotationManager?: AnnotationManager
  ): CallToAction[] {
    const ctas: CallToAction[] = [];
    
    for (const qrResult of qrResults) {
      const bestHeading = findBestHeading(headings, qrResult.coordinates);
      const cta = this.createFromQRCode(qrResult, pageNumber, bestHeading, userId, documentId, annotationManager);
      
      if (cta) {
        ctas.push(cta);
      }
    }
    
    return ctas;
  }

  /**
   * Generate URL from QR code content
   * @param qrContent - Raw QR code content
   * @returns Formatted URL
   */
  private generateURL(qrContent: string): string {
    const trimmedContent = qrContent.trim();
    
    // Check if QR code content is already a complete URL
    if (this.isValidURL(trimmedContent)) {
      return trimmedContent;
    }
    
    // For non-URL content, append to base URL
    // Handle base URL trailing slash
    const baseUrl = this.config.baseUrl.endsWith('/') 
      ? this.config.baseUrl.slice(0, -1) 
      : this.config.baseUrl;
    
    // Encode the QR content as a URL parameter
    const encodedContent = encodeURIComponent(trimmedContent);
    
    // Return base URL with QR content as parameter
    return `${baseUrl}?qr=${encodedContent}`;
  }

  /**
   * Generate title for the CTA
   * @param pageHeading - Heading text from page (can be null)
   * @param pageNumber - Page number for fallback title
   * @returns Generated title
   */
  private generateTitle(pageHeading: string | null, pageNumber: number): string {
    if (pageHeading && pageHeading.trim().length > 0) {
      return this.truncateTitle(pageHeading.trim());
    }
    
    // Use fallback title template
    return this.config.defaultTitleTemplate.replace('{pageNumber}', pageNumber.toString());
  }

  /**
   * Truncate title to maximum length
   * @param title - Original title text
   * @returns Truncated title
   */
  private truncateTitle(title: string): string {
    if (title.length <= this.config.maxTitleLength) {
      return title;
    }
    
    // Find a good break point (space) near the limit
    const truncateAt = this.config.maxTitleLength - 3; // Reserve space for "..."
    const lastSpaceIndex = title.lastIndexOf(' ', truncateAt);
    
    if (lastSpaceIndex > truncateAt - 10) {
      // Use space if it's reasonably close to the limit
      return title.substring(0, lastSpaceIndex) + '...';
    }
    
    // Hard truncate if no good break point
    return title.substring(0, truncateAt) + '...';
  }

  /**
   * Check if a string is a valid URL
   * @param str - String to validate
   * @returns True if string is a valid URL
   */
  private isValidURL(str: string): boolean {
    try {
      const url = new URL(str);
      return url.protocol === 'http:' || url.protocol === 'https:';
    } catch {
      return false;
    }
  }

  /**
   * Generate unique ID for CTA based on QR content and location
   * @param qrResult - QR code scan result
   * @param pageNumber - Page number
   * @param documentId - Document ID
   * @returns Unique CTA ID
   */
  private generateCTAId(qrResult: QRCodeScanResult, pageNumber: number, documentId: string): string {
    // Create a hash-like ID based on content and position
    const contentHash = this.simpleHash(qrResult.content);
    const positionHash = this.simpleHash(`${qrResult.coordinates.x},${qrResult.coordinates.y}`);
    
    return `auto-cta-${documentId}-p${pageNumber}-${contentHash}-${positionHash}`;
  }

  /**
   * Simple hash function for generating consistent IDs
   * @param str - String to hash
   * @returns Simple hash string
   */
  private simpleHash(str: string): string {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return Math.abs(hash).toString(36);
  }

  /**
   * Update configuration
   * @param newConfig - Partial configuration to merge
   */
  updateConfig(newConfig: Partial<AutoCTAConfig>): void {
    this.config = { ...this.config, ...newConfig };
  }

  /**
   * Get current configuration
   * @returns Current configuration
   */
  getConfig(): AutoCTAConfig {
    return { ...this.config };
  }
}

// Export default instance with default configuration
export const autoCTAGenerator = new AutoCTAGenerator();