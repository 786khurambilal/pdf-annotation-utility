import { QRScanningManager, QRScanningState, QRScanProgress } from './QRScanningManager';
import { QRCodeScanner, QRCodeScanResult } from './QRCodeScanner';
import { PageContentExtractor, PageHeading } from './PageContentExtractor';
import { AutoCTAGenerator } from './AutoCTAGenerator';
import { CallToAction } from '../types/annotation.types';

// Mock dependencies
const mockQRScanner: jest.Mocked<QRCodeScanner> = {
  scanPage: jest.fn(),
  isQRCodeDetectionSupported: jest.fn()
};

const mockContentExtractor: jest.Mocked<PageContentExtractor> = {
  extractHeadings: jest.fn(),
  findBestHeadingForArea: jest.fn()
};

const mockCTAGenerator: jest.Mocked<AutoCTAGenerator> = {
  createFromQRCode: jest.fn()
};

// Mock data
const mockQRResult: QRCodeScanResult = {
  content: 'https://example.com',
  coordinates: { x: 100, y: 100, width: 50, height: 50 },
  confidence: 0.95
};

const mockHeading: PageHeading = {
  text: 'Chapter 1: Introduction',
  level: 1,
  coordinates: { x: 50, y: 50, width: 200, height: 30 }
};

const mockCTA: CallToAction = {
  id: 'cta-1',
  type: 'cta',
  userId: 'user-1',
  documentId: 'doc-1',
  pageNumber: 1,
  coordinates: mockQRResult.coordinates,
  createdAt: new Date(),
  url: 'http://test.com/https://example.com',
  label: 'Chapter 1: Introduction',
  isAutoGenerated: true,
  qrCodeContent: 'https://example.com',
  autoGeneratedAt: new Date()
};

describe('QRScanningManager', () => {
  let manager: QRScanningManager;
  let mockGetPageCanvas: jest.Mock;

  beforeEach(() => {
    jest.clearAllMocks();
    
    manager = new QRScanningManager(
      mockQRScanner,
      mockContentExtractor,
      mockCTAGenerator
    );

    mockGetPageCanvas = jest.fn().mockResolvedValue(document.createElement('canvas'));
    
    // Setup default mock implementations
    mockQRScanner.scanPage.mockResolvedValue([]);
    mockContentExtractor.extractHeadings.mockResolvedValue([]);
    mockContentExtractor.findBestHeadingForArea.mockReturnValue(null);
    mockCTAGenerator.createFromQRCode.mockReturnValue(mockCTA);
  });

  describe('Initial State', () => {
    it('should initialize with correct default state', () => {
      const state = manager.getState();
      
      expect(state).toEqual({
        isScanning: false,
        isPaused: false,
        currentPage: 0,
        totalPages: 0,
        foundQRCodes: 0,
        generatedCTAs: 0,
        errors: []
      });
    });

    it('should have no current progress initially', () => {
      expect(manager.getCurrentProgress()).toBeNull();
    });
  });

  describe('State Change Notifications', () => {
    it('should notify subscribers when state changes', () => {
      const callback = jest.fn();
      const unsubscribe = manager.onStateChange(callback);

      // Start scanning to trigger state change
      manager.startScanning('doc-1', 1, mockGetPageCanvas, 'user-1');

      expect(callback).toHaveBeenCalledWith(
        expect.objectContaining({
          isScanning: true,
          totalPages: 1
        })
      );

      unsubscribe();
    });

    it('should allow unsubscribing from state changes', () => {
      const callback = jest.fn();
      const unsubscribe = manager.onStateChange(callback);
      
      unsubscribe();
      
      // This should not trigger the callback
      manager.startScanning('doc-1', 1, mockGetPageCanvas, 'user-1');
      
      expect(callback).not.toHaveBeenCalled();
    });

    it('should handle errors in state change callbacks gracefully', () => {
      const errorCallback = jest.fn().mockImplementation(() => {
        throw new Error('Callback error');
      });
      const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();

      manager.onStateChange(errorCallback);
      manager.startScanning('doc-1', 1, mockGetPageCanvas, 'user-1');

      expect(consoleErrorSpy).toHaveBeenCalledWith('Error in state change callback:', expect.any(Error));
      
      consoleErrorSpy.mockRestore();
    });
  });

  describe('Progress Notifications', () => {
    it('should notify progress subscribers during scanning', async () => {
      const progressCallback = jest.fn();
      manager.onProgress(progressCallback);

      mockQRScanner.scanPage.mockResolvedValue([mockQRResult]);
      mockContentExtractor.extractHeadings.mockResolvedValue([mockHeading]);
      mockContentExtractor.findBestHeadingForArea.mockReturnValue(mockHeading.text);

      await manager.startScanning('doc-1', 1, mockGetPageCanvas, 'user-1');

      expect(progressCallback).toHaveBeenCalledWith(
        expect.objectContaining({
          documentId: 'doc-1',
          totalPages: 1,
          scannedPages: 1,
          foundQRCodes: [mockQRResult],
          generatedCTAs: [mockCTA]
        })
      );
    });

    it('should allow unsubscribing from progress notifications', () => {
      const callback = jest.fn();
      const unsubscribe = manager.onProgress(callback);
      
      unsubscribe();
      
      manager.startScanning('doc-1', 1, mockGetPageCanvas, 'user-1');
      
      expect(callback).not.toHaveBeenCalled();
    });
  });

  describe('Scanning Process', () => {
    it('should scan all pages successfully', async () => {
      mockQRScanner.scanPage.mockResolvedValue([mockQRResult]);
      mockContentExtractor.extractHeadings.mockResolvedValue([mockHeading]);
      mockContentExtractor.findBestHeadingForArea.mockReturnValue(mockHeading.text);

      const result = await manager.startScanning('doc-1', 2, mockGetPageCanvas, 'user-1');

      expect(mockGetPageCanvas).toHaveBeenCalledTimes(2);
      expect(mockQRScanner.scanPage).toHaveBeenCalledTimes(2);
      expect(result).toHaveLength(2);
      expect(result[0]).toEqual(mockCTA);

      const finalState = manager.getState();
      expect(finalState.isScanning).toBe(false);
      expect(finalState.foundQRCodes).toBe(2);
      expect(finalState.generatedCTAs).toBe(2);
      expect(finalState.completedAt).toBeDefined();
    });

    it('should handle pages with no QR codes', async () => {
      mockQRScanner.scanPage.mockResolvedValue([]);

      const result = await manager.startScanning('doc-1', 1, mockGetPageCanvas, 'user-1');

      expect(result).toHaveLength(0);
      
      const finalState = manager.getState();
      expect(finalState.foundQRCodes).toBe(0);
      expect(finalState.generatedCTAs).toBe(0);
    });

    it('should handle multiple QR codes on a single page', async () => {
      const secondQRResult: QRCodeScanResult = {
        content: 'https://another.com',
        coordinates: { x: 200, y: 200, width: 50, height: 50 },
        confidence: 0.9
      };

      mockQRScanner.scanPage.mockResolvedValue([mockQRResult, secondQRResult]);
      mockContentExtractor.extractHeadings.mockResolvedValue([mockHeading]);
      mockContentExtractor.findBestHeadingForArea.mockReturnValue(mockHeading.text);

      const result = await manager.startScanning('doc-1', 1, mockGetPageCanvas, 'user-1');

      expect(result).toHaveLength(2);
      expect(mockCTAGenerator.createFromQRCode).toHaveBeenCalledTimes(2);
      
      const finalState = manager.getState();
      expect(finalState.foundQRCodes).toBe(2);
      expect(finalState.generatedCTAs).toBe(2);
    });

    it('should prevent starting multiple scans simultaneously', async () => {
      const firstScan = manager.startScanning('doc-1', 1, mockGetPageCanvas, 'user-1');
      
      await expect(
        manager.startScanning('doc-2', 1, mockGetPageCanvas, 'user-1')
      ).rejects.toThrow('Scanning is already in progress');

      await firstScan;
    });
  });

  describe('Error Handling', () => {
    it('should handle page canvas errors gracefully', async () => {
      mockGetPageCanvas.mockRejectedValueOnce(new Error('Canvas error'));

      const result = await manager.startScanning('doc-1', 2, mockGetPageCanvas, 'user-1');

      expect(result).toHaveLength(0);
      
      const finalState = manager.getState();
      expect(finalState.errors).toHaveLength(1);
      expect(finalState.errors[0]).toEqual({
        pageNumber: 1,
        error: 'Page scan failed: Canvas error'
      });
    });

    it('should handle QR scanning errors gracefully', async () => {
      mockQRScanner.scanPage.mockRejectedValueOnce(new Error('QR scan error'));

      const result = await manager.startScanning('doc-1', 1, mockGetPageCanvas, 'user-1');

      expect(result).toHaveLength(0);
      
      const finalState = manager.getState();
      expect(finalState.errors).toHaveLength(1);
      expect(finalState.errors[0].error).toContain('QR scan error');
    });

    it('should handle CTA generation errors gracefully', async () => {
      mockQRScanner.scanPage.mockResolvedValue([mockQRResult]);
      mockContentExtractor.extractHeadings.mockResolvedValue([mockHeading]);
      mockContentExtractor.findBestHeadingForArea.mockReturnValue(mockHeading.text);
      mockCTAGenerator.createFromQRCode.mockImplementation(() => {
        throw new Error('CTA generation error');
      });

      const result = await manager.startScanning('doc-1', 1, mockGetPageCanvas, 'user-1');

      expect(result).toHaveLength(0);
      
      const finalState = manager.getState();
      expect(finalState.errors).toHaveLength(1);
      expect(finalState.errors[0].error).toContain('QR code processing failed');
    });

    it('should handle unknown errors gracefully', async () => {
      mockGetPageCanvas.mockRejectedValueOnce('String error');

      const result = await manager.startScanning('doc-1', 1, mockGetPageCanvas, 'user-1');

      const finalState = manager.getState();
      expect(finalState.errors[0].error).toContain('Unknown error scanning page');
    });
  });

  describe('Pause and Resume Functionality', () => {
    it('should pause and resume scanning', async () => {
      let scanCallCount = 0;
      mockQRScanner.scanPage.mockImplementation(async () => {
        scanCallCount++;
        if (scanCallCount === 1) {
          // Pause after first page
          manager.pauseScanning();
          
          // Resume after a short delay
          setTimeout(() => manager.resumeScanning(), 10);
        }
        return [];
      });

      const startTime = Date.now();
      await manager.startScanning('doc-1', 2, mockGetPageCanvas, 'user-1');
      const endTime = Date.now();

      // Should have taken at least 10ms due to pause
      expect(endTime - startTime).toBeGreaterThanOrEqual(10);
      expect(mockQRScanner.scanPage).toHaveBeenCalledTimes(2);
    });

    it('should handle pause when not scanning', () => {
      manager.pauseScanning();
      
      const state = manager.getState();
      expect(state.isPaused).toBe(false);
    });

    it('should handle resume when not paused', () => {
      manager.resumeScanning();
      
      const state = manager.getState();
      expect(state.isPaused).toBe(false);
    });

    it('should handle multiple pause calls', () => {
      manager.startScanning('doc-1', 1, mockGetPageCanvas, 'user-1');
      
      manager.pauseScanning();
      manager.pauseScanning(); // Second call should be ignored
      
      const state = manager.getState();
      expect(state.isPaused).toBe(true);
    });
  });

  describe('Stop Functionality', () => {
    it('should stop scanning in progress', async () => {
      let scanStarted = false;
      mockQRScanner.scanPage.mockImplementation(async () => {
        if (!scanStarted) {
          scanStarted = true;
          // Stop scanning after first page starts
          setTimeout(() => manager.stopScanning(), 1);
        }
        return [];
      });

      const result = await manager.startScanning('doc-1', 5, mockGetPageCanvas, 'user-1');

      expect(result).toHaveLength(0);
      
      const finalState = manager.getState();
      expect(finalState.isScanning).toBe(false);
      expect(finalState.completedAt).toBeDefined();
    });

    it('should handle stop when not scanning', () => {
      manager.stopScanning();
      
      const state = manager.getState();
      expect(state.isScanning).toBe(false);
    });

    it('should resume if paused when stopping', async () => {
      let pauseResolved = false;
      let scanningStarted = false;
      
      mockQRScanner.scanPage.mockImplementation(async () => {
        if (!scanningStarted) {
          scanningStarted = true;
          manager.pauseScanning();
          
          // Stop while paused
          setTimeout(() => {
            manager.stopScanning();
            pauseResolved = true;
          }, 1);
          
          // Wait for stop to be called
          await new Promise(resolve => setTimeout(resolve, 5));
        }
        return [];
      });

      await manager.startScanning('doc-1', 1, mockGetPageCanvas, 'user-1');
      
      expect(pauseResolved).toBe(true);
    });
  });

  describe('Reset Functionality', () => {
    it('should reset state to initial values', async () => {
      mockQRScanner.scanPage.mockResolvedValue([mockQRResult]);
      
      await manager.startScanning('doc-1', 1, mockGetPageCanvas, 'user-1');
      
      manager.reset();
      
      const state = manager.getState();
      expect(state).toEqual({
        isScanning: false,
        isPaused: false,
        currentPage: 0,
        totalPages: 0,
        foundQRCodes: 0,
        generatedCTAs: 0,
        errors: []
      });
      
      expect(manager.getCurrentProgress()).toBeNull();
    });

    it('should stop scanning before resetting', () => {
      manager.startScanning('doc-1', 1, mockGetPageCanvas, 'user-1');
      
      const stopSpy = jest.spyOn(manager, 'stopScanning');
      manager.reset();
      
      expect(stopSpy).toHaveBeenCalled();
    });
  });

  describe('Progress Tracking', () => {
    it('should track progress correctly during scanning', async () => {
      // Mock different results for different pages
      let pageCount = 0;
      mockQRScanner.scanPage.mockImplementation(async () => {
        pageCount++;
        if (pageCount === 1) {
          return [mockQRResult];
        } else {
          return []; // No QR codes on page 2
        }
      });
      
      mockContentExtractor.extractHeadings.mockResolvedValue([mockHeading]);
      mockContentExtractor.findBestHeadingForArea.mockReturnValue(mockHeading.text);

      const progressUpdates: QRScanProgress[] = [];
      manager.onProgress((progress) => {
        progressUpdates.push({ ...progress });
      });

      await manager.startScanning('doc-1', 2, mockGetPageCanvas, 'user-1');

      // Should have 3 updates: page 1 with QR, page 2 without QR, and completion
      expect(progressUpdates).toHaveLength(3);
      
      // First page progress (has QR code)
      expect(progressUpdates[0]).toMatchObject({
        documentId: 'doc-1',
        totalPages: 2,
        scannedPages: 1,
        foundQRCodes: [mockQRResult],
        generatedCTAs: [mockCTA]
      });
      
      // Second page progress (no QR codes found)
      expect(progressUpdates[1]).toMatchObject({
        scannedPages: 2,
        foundQRCodes: [mockQRResult], // Still only one QR code from page 1
        generatedCTAs: [mockCTA] // Still only one CTA from page 1
      });
      
      // Final completion progress
      expect(progressUpdates[2]).toMatchObject({
        scannedPages: 2,
        foundQRCodes: [mockQRResult], // Still only one QR code
        generatedCTAs: [mockCTA], // Still only one CTA
        completedAt: expect.any(Date)
      });
    });

    it('should include errors in progress tracking', async () => {
      mockGetPageCanvas.mockRejectedValueOnce(new Error('Canvas error'));
      mockQRScanner.scanPage.mockResolvedValue([]);

      const progressUpdates: QRScanProgress[] = [];
      manager.onProgress((progress) => {
        progressUpdates.push({ ...progress });
      });

      await manager.startScanning('doc-1', 2, mockGetPageCanvas, 'user-1');

      const finalProgress = progressUpdates[progressUpdates.length - 1];
      expect(finalProgress.errors).toHaveLength(1);
      expect(finalProgress.errors[0]).toEqual({
        pageNumber: 1,
        error: 'Page scan failed: Canvas error'
      });
    });
  });
});