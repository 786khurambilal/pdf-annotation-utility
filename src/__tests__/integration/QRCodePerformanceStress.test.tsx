import { screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { renderWithProviders, createMockPdfFile } from '../../test-utils';
import { PDFViewerContainer } from '../../components/pdf/PDFViewerContainer';
import { QRCodeScannerService } from '../../utils/QRCodeScanner';

// Mock QR code utilities for performance testing
jest.mock('../../utils/QRCodeScanner', () => ({
  QRCodeScannerService: jest.fn().mockImplementation(() => ({
    scanPage: jest.fn().mockImplementation(async () => {
      await new Promise(resolve => setTimeout(resolve, 50));
      return [{
        content: `https://example.com/page-${Math.random()}`,
        coordinates: { x: 100, y: 200, width: 80, height: 80 },
        confidence: 0.9
      }];
    }),
    isQRCodeDetectionSupported: jest.fn().mockReturnValue(true)
  }))
}));

jest.mock('../../utils/PageContentExtractor', () => ({
  PageContentExtractor: jest.fn().mockImplementation(() => ({
    extractHeadings: jest.fn().mockResolvedValue([{
      text: 'Test Heading',
      level: 1,
      coordinates: { x: 50, y: 150, width: 200, height: 30 }
    }]),
    findBestHeadingForArea: jest.fn().mockReturnValue('Test Heading')
  }))
}));

jest.mock('../../utils/AutoCTAGenerator', () => ({
  AutoCTAGenerator: jest.fn().mockImplementation(() => ({
    createFromQRCode: jest.fn().mockImplementation((qrResult, pageNumber, heading, userId, documentId) => ({
      id: `auto-cta-${Math.random()}`,
      type: 'cta',
      userId,
      documentId,
      pageNumber,
      url: qrResult.content.startsWith('http') ? qrResult.content : `http://test.com/${qrResult.content}`,
      label: heading || `QR Code Link - Page ${pageNumber}`,
      coordinates: qrResult.coordinates,
      isAutoGenerated: true,
      qrCodeContent: qrResult.content,
      autoGeneratedAt: new Date(),
      createdAt: new Date(),
      updatedAt: new Date()
    }))
  }))
}));

// Performance monitoring utilities
const measurePerformance = async (operation: () => Promise<void>) => {
  const startTime = performance.now();
  const startMemory = (performance as any).memory?.usedJSHeapSize || 0;
  
  await operation();
  
  const endTime = performance.now();
  const endMemory = (performance as any).memory?.usedJSHeapSize || 0;
  
  return {
    duration: endTime - startTime,
    memoryDelta: endMemory - startMemory
  };
};

describe('QR Code Performance and Stress Tests', () => {
  let user: ReturnType<typeof userEvent.setup>;

  beforeEach(() => {
    user = userEvent.setup();
    global.URL.createObjectURL = jest.fn(() => 'mock-pdf-url');
    global.URL.revokeObjectURL = jest.fn();
    
    // Mock performance.memory if not available
    if (!(performance as any).memory) {
      (performance as any).memory = {
        usedJSHeapSize: 50000000, // 50MB baseline
        totalJSHeapSize: 100000000,
        jsHeapSizeLimit: 2000000000
      };
    }
    
    jest.clearAllMocks();
  });

  describe('Large PDF Performance', () => {
    it('should handle large PDFs with many pages efficiently', async () => {
      // Mock scanner for large PDF
      (QRCodeScannerService as unknown as jest.Mock).mockImplementation(() => ({
        scanPage: jest.fn().mockImplementation(async () => {
          // Simulate realistic scanning time
          await new Promise(resolve => setTimeout(resolve, 50));
          return [
            {
              content: `https://example.com/page-${Math.random()}`,
              coordinates: { x: 100, y: 200, width: 80, height: 80 },
              confidence: 0.9
            }
          ];
        }),
        isQRCodeDetectionSupported: jest.fn().mockReturnValue(true)
      }));

      const performanceMetrics = await measurePerformance(async () => {
        renderWithProviders(
          <PDFViewerContainer enableVirtualization={false} />,
          { initialUser: { id: 'test-user', name: 'Test User' } }
        );

        // Create large PDF (simulate 50 pages)
        const largePdfFile = createMockPdfFile('large-document.pdf', 10 * 1024 * 1024); // 10MB
        const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
        await user.upload(fileInput, largePdfFile);

        await waitFor(() => {
          expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
        }, { timeout: 10000 });

        // Wait for QR scanning to complete
        await new Promise(resolve => setTimeout(resolve, 5000));
      });

      // Performance assertions
      expect(performanceMetrics.duration).toBeLessThan(15000); // 15 seconds max
      expect(performanceMetrics.memoryDelta).toBeLessThan(100 * 1024 * 1024); // 100MB max memory increase

      // Verify functionality
      expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      expect(QRCodeScannerService).toHaveBeenCalled();
    });

    it('should maintain UI responsiveness during large PDF scanning', async () => {
      // Mock slow scanning to test responsiveness
      (QRCodeScannerService as unknown as jest.Mock).mockImplementation(() => ({
        scanPage: jest.fn().mockImplementation(async () => {
          await new Promise(resolve => setTimeout(resolve, 200)); // Slower scanning
          return [
            {
              content: 'slow-scan-content',
              coordinates: { x: 100, y: 200, width: 80, height: 80 },
              confidence: 0.9
            }
          ];
        }),
        isQRCodeDetectionSupported: jest.fn().mockReturnValue(true)
      }));

      renderWithProviders(
        <PDFViewerContainer enableVirtualization={false} />,
        { initialUser: { id: 'test-user', name: 'Test User' } }
      );

      const mockFile = createMockPdfFile('responsiveness-test.pdf');
      const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
      await user.upload(fileInput, mockFile);

      await waitFor(() => {
        expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      });

      // Test UI responsiveness during scanning
      const startTime = performance.now();
      
      // Navigate pages quickly
      const nextButton = screen.getByRole('button', { name: /next page/i });
      await user.click(nextButton);
      
      const navigationTime = performance.now() - startTime;
      
      // Navigation should be fast even during scanning
      expect(navigationTime).toBeLessThan(500); // 500ms max
      
      await waitFor(() => {
        expect(screen.getByDisplayValue('2')).toBeInTheDocument(); // Page input shows page 2
      });
    });

    it('should handle memory cleanup properly', async () => {
      const initialMemory = (performance as any).memory.usedJSHeapSize;

      (QRCodeScannerService as unknown as jest.Mock).mockImplementation(() => ({
        scanPage: jest.fn().mockImplementation(async () => {
          // Create temporary large objects to test cleanup
          new Array(10000).fill('memory-test-data');
          await new Promise(resolve => setTimeout(resolve, 10));
          return [
            {
              content: 'memory-test',
              coordinates: { x: 100, y: 200, width: 80, height: 80 },
              confidence: 0.9
            }
          ];
        }),
        isQRCodeDetectionSupported: jest.fn().mockReturnValue(true)
      }));

      const { unmount } = renderWithProviders(
        <PDFViewerContainer enableVirtualization={false} />,
        { initialUser: { id: 'test-user', name: 'Test User' } }
      );

      const mockFile = createMockPdfFile('memory-cleanup-test.pdf');
      const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
      await user.upload(fileInput, mockFile);

      await waitFor(() => {
        expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      });

      // Wait for scanning
      await new Promise(resolve => setTimeout(resolve, 2000));

      // Unmount component
      unmount();

      // Force garbage collection if available
      if ((global as any).gc) {
        (global as any).gc();
      }

      // Wait for cleanup
      await new Promise(resolve => setTimeout(resolve, 1000));

      const finalMemory = (performance as any).memory.usedJSHeapSize;
      const memoryIncrease = finalMemory - initialMemory;

      // Memory increase should be reasonable
      expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024); // 50MB max
    });
  });

  describe('Multiple QR Codes Performance', () => {
    it('should handle PDFs with many QR codes efficiently', async () => {
      // Mock many QR codes per page
      const manyQRCodes = Array.from({ length: 20 }, (_, i) => ({
        content: `https://example.com/qr-${i}`,
        coordinates: { x: 50 + (i % 5) * 100, y: 100 + Math.floor(i / 5) * 100, width: 80, height: 80 },
        confidence: 0.9
      }));

      (QRCodeScannerService as unknown as jest.Mock).mockImplementation(() => ({
        scanPage: jest.fn().mockResolvedValue(manyQRCodes),
        isQRCodeDetectionSupported: jest.fn().mockReturnValue(true)
      }));

      const performanceMetrics = await measurePerformance(async () => {
        renderWithProviders(
          <PDFViewerContainer enableVirtualization={false} />,
          { initialUser: { id: 'test-user', name: 'Test User' } }
        );

        const mockFile = createMockPdfFile('many-qr-codes.pdf');
        const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
        await user.upload(fileInput, mockFile);

        await waitFor(() => {
          expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
        });

        // Wait for all QR codes to be processed
        await new Promise(resolve => setTimeout(resolve, 3000));
      });

      // Should handle many QR codes efficiently
      expect(performanceMetrics.duration).toBeLessThan(8000); // 8 seconds max
      expect(performanceMetrics.memoryDelta).toBeLessThan(50 * 1024 * 1024); // 50MB max

      // Verify QR codes were processed
      expect(QRCodeScannerService).toHaveBeenCalled();
    });

    it('should batch process QR codes to avoid blocking', async () => {
      let processingBatches = 0;
      const batchSize = 5;

      (QRCodeScannerService as unknown as jest.Mock).mockImplementation(() => ({
        scanPage: jest.fn().mockImplementation(async () => {
          processingBatches++;
          // Simulate batch processing delay
          await new Promise(resolve => setTimeout(resolve, 100));
          
          return Array.from({ length: batchSize }, (_, i) => ({
            content: `batch-${processingBatches}-qr-${i}`,
            coordinates: { x: 100 + i * 50, y: 200, width: 80, height: 80 },
            confidence: 0.9
          }));
        }),
        isQRCodeDetectionSupported: jest.fn().mockReturnValue(true)
      }));

      renderWithProviders(
        <PDFViewerContainer enableVirtualization={false} />,
        { initialUser: { id: 'test-user', name: 'Test User' } }
      );

      const mockFile = createMockPdfFile('batch-processing.pdf');
      const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
      await user.upload(fileInput, mockFile);

      await waitFor(() => {
        expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      });

      // Test UI remains responsive during batch processing
      const startTime = performance.now();
      
      // Try to interact with UI
      const nextButton = screen.getByRole('button', { name: /next page/i });
      await user.click(nextButton);
      
      const interactionTime = performance.now() - startTime;
      
      // Interaction should be fast
      expect(interactionTime).toBeLessThan(300);
      
      // Wait for batch processing to complete
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Should have processed in batches
      expect(processingBatches).toBeGreaterThan(0);
    });
  });

  describe('Concurrent Operations Stress Test', () => {
    it('should handle concurrent PDF uploads and QR scanning', async () => {
      (QRCodeScannerService as unknown as jest.Mock).mockImplementation(() => ({
        scanPage: jest.fn().mockImplementation(async () => {
          await new Promise(resolve => setTimeout(resolve, 100));
          return [
            {
              content: `concurrent-test-${Date.now()}`,
              coordinates: { x: 100, y: 200, width: 80, height: 80 },
              confidence: 0.9
            }
          ];
        }),
        isQRCodeDetectionSupported: jest.fn().mockReturnValue(true)
      }));

      const performanceMetrics = await measurePerformance(async () => {
        renderWithProviders(
          <PDFViewerContainer enableVirtualization={false} />,
          { initialUser: { id: 'test-user', name: 'Test User' } }
        );

        // Upload first PDF
        const mockFile1 = createMockPdfFile('concurrent-1.pdf');
        const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
        await user.upload(fileInput, mockFile1);

        await waitFor(() => {
          expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
        });

        // Quickly upload second PDF (simulating user behavior)
        const mockFile2 = createMockPdfFile('concurrent-2.pdf');
        await user.upload(fileInput, mockFile2);

        // Wait for processing
        await new Promise(resolve => setTimeout(resolve, 3000));
      });

      // Should handle concurrent operations
      expect(performanceMetrics.duration).toBeLessThan(10000);
      expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
    });

    it('should handle rapid user interactions during scanning', async () => {
      (QRCodeScannerService as unknown as jest.Mock).mockImplementation(() => ({
        scanPage: jest.fn().mockImplementation(async () => {
          await new Promise(resolve => setTimeout(resolve, 500)); // Slow scanning
          return [
            {
              content: 'rapid-interaction-test',
              coordinates: { x: 100, y: 200, width: 80, height: 80 },
              confidence: 0.9
            }
          ];
        }),
        isQRCodeDetectionSupported: jest.fn().mockReturnValue(true)
      }));

      renderWithProviders(
        <PDFViewerContainer enableVirtualization={false} />,
        { initialUser: { id: 'test-user', name: 'Test User' } }
      );

      const mockFile = createMockPdfFile('rapid-interaction.pdf');
      const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
      await user.upload(fileInput, mockFile);

      await waitFor(() => {
        expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      });

      // Perform rapid interactions
      const nextButton = screen.getByRole('button', { name: /next page/i });
      const prevButton = screen.getByRole('button', { name: /previous page/i });

      const interactionTimes: number[] = [];

      for (let i = 0; i < 10; i++) {
        const startTime = performance.now();
        
        if (i % 2 === 0) {
          await user.click(nextButton);
        } else {
          await user.click(prevButton);
        }
        
        const endTime = performance.now();
        interactionTimes.push(endTime - startTime);
        
        // Small delay between interactions
        await new Promise(resolve => setTimeout(resolve, 50));
      }

      // All interactions should be responsive
      const avgInteractionTime = interactionTimes.reduce((a, b) => a + b, 0) / interactionTimes.length;
      expect(avgInteractionTime).toBeLessThan(200); // 200ms average
      expect(Math.max(...interactionTimes)).toBeLessThan(500); // 500ms max
    });
  });

  describe('Memory Stress Tests', () => {
    it('should handle memory pressure gracefully', async () => {
      // Mock memory-intensive operations
      (QRCodeScannerService as unknown as jest.Mock).mockImplementation(() => ({
        scanPage: jest.fn().mockImplementation(async () => {
          // Create large temporary objects
          new Array(100000).fill({
            data: new Array(100).fill('memory-stress-test'),
            timestamp: Date.now()
          });
          
          await new Promise(resolve => setTimeout(resolve, 50));
          
          // Return result and let large data be garbage collected
          return [
            {
              content: 'memory-stress-content',
              coordinates: { x: 100, y: 200, width: 80, height: 80 },
              confidence: 0.9
            }
          ];
        }),
        isQRCodeDetectionSupported: jest.fn().mockReturnValue(true)
      }));

      const initialMemory = (performance as any).memory.usedJSHeapSize;

      renderWithProviders(
        <PDFViewerContainer enableVirtualization={false} />,
        { initialUser: { id: 'test-user', name: 'Test User' } }
      );

      const mockFile = createMockPdfFile('memory-stress.pdf');
      const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
      await user.upload(fileInput, mockFile);

      await waitFor(() => {
        expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      });

      // Wait for memory-intensive scanning
      await new Promise(resolve => setTimeout(resolve, 2000));

      const peakMemory = (performance as any).memory.usedJSHeapSize;
      const memoryIncrease = peakMemory - initialMemory;

      // Should handle memory pressure without excessive growth
      expect(memoryIncrease).toBeLessThan(200 * 1024 * 1024); // 200MB max

      // Application should remain functional
      expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      expect(screen.getByDisplayValue('1')).toBeInTheDocument(); // Page input shows current page
    });

    it('should recover from out-of-memory scenarios', async () => {
      let memoryErrorThrown = false;

      (QRCodeScannerService as unknown as jest.Mock).mockImplementation(() => ({
        scanPage: jest.fn().mockImplementation(async () => {
          if (!memoryErrorThrown) {
            memoryErrorThrown = true;
            throw new Error('Out of memory');
          }
          
          // Recovery attempt
          return [
            {
              content: 'recovery-content',
              coordinates: { x: 100, y: 200, width: 80, height: 80 },
              confidence: 0.9
            }
          ];
        }),
        isQRCodeDetectionSupported: jest.fn().mockReturnValue(true)
      }));

      renderWithProviders(
        <PDFViewerContainer enableVirtualization={false} />,
        { initialUser: { id: 'test-user', name: 'Test User' } }
      );

      const mockFile = createMockPdfFile('memory-recovery.pdf');
      const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
      await user.upload(fileInput, mockFile);

      await waitFor(() => {
        expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      });

      // Wait for error and recovery
      await new Promise(resolve => setTimeout(resolve, 2000));

      // Should have attempted recovery
      expect(memoryErrorThrown).toBe(true);
      
      // PDF should still be functional
      expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
    });
  });

  describe('Long-Running Operations', () => {
    it('should handle extended scanning sessions', async () => {
      let scanCount = 0;

      (QRCodeScannerService as unknown as jest.Mock).mockImplementation(() => ({
        scanPage: jest.fn().mockImplementation(async () => {
          scanCount++;
          await new Promise(resolve => setTimeout(resolve, 100));
          
          return [
            {
              content: `extended-scan-${scanCount}`,
              coordinates: { x: 100, y: 200, width: 80, height: 80 },
              confidence: 0.9
            }
          ];
        }),
        isQRCodeDetectionSupported: jest.fn().mockReturnValue(true)
      }));

      const startTime = performance.now();
      const initialMemory = (performance as any).memory.usedJSHeapSize;

      renderWithProviders(
        <PDFViewerContainer enableVirtualization={false} />,
        { initialUser: { id: 'test-user', name: 'Test User' } }
      );

      const mockFile = createMockPdfFile('extended-session.pdf');
      const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
      await user.upload(fileInput, mockFile);

      await waitFor(() => {
        expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      });

      // Simulate extended scanning session
      await new Promise(resolve => setTimeout(resolve, 8000));

      const endTime = performance.now();
      const finalMemory = (performance as any).memory.usedJSHeapSize;

      // Should handle extended operations
      expect(endTime - startTime).toBeLessThan(15000); // 15 seconds max
      expect(finalMemory - initialMemory).toBeLessThan(100 * 1024 * 1024); // 100MB max
      expect(scanCount).toBeGreaterThan(0);

      // UI should remain responsive
      const nextButton = screen.getByRole('button', { name: /next page/i });
      await user.click(nextButton);

      await waitFor(() => {
        expect(screen.getByDisplayValue('2')).toBeInTheDocument(); // Page input shows page 2
      });
    });
  });
});