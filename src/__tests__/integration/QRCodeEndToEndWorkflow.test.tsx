import { screen, waitFor, fireEvent, act } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { renderWithProviders, createMockPdfFile } from '../../test-utils';
import { PDFViewerContainer } from '../../components/pdf/PDFViewerContainer';
import { QRCodeScannerService } from '../../utils/QRCodeScanner';
import { PageContentExtractor } from '../../utils/PageContentExtractor';
import { AutoCTAGenerator } from '../../utils/AutoCTAGenerator';

// Mock QR code detection utilities with realistic behavior
const mockQRResults = [
  {
    content: 'https://example.com/product1',
    coordinates: { x: 100, y: 200, width: 80, height: 80 },
    confidence: 0.95
  },
  {
    content: 'contact-info',
    coordinates: { x: 300, y: 400, width: 80, height: 80 },
    confidence: 0.88
  }
];

const mockHeadings = [
  {
    text: 'Product Overview',
    level: 1,
    coordinates: { x: 50, y: 150, width: 200, height: 30 }
  },
  {
    text: 'Contact Information',
    level: 2,
    coordinates: { x: 250, y: 350, width: 180, height: 25 }
  }
];

jest.mock('../../utils/QRCodeScanner', () => ({
  QRCodeScannerService: {
    getInstance: jest.fn(() => ({
      scanPage: jest.fn().mockImplementation(async () => {
        // Simulate scanning delay
        await new Promise(resolve => setTimeout(resolve, 100));
        return mockQRResults;
      }),
      isQRCodeDetectionSupported: jest.fn().mockReturnValue(true)
    }))
  },
  qrCodeScanner: {
    scanPage: jest.fn().mockImplementation(async () => {
      await new Promise(resolve => setTimeout(resolve, 100));
      return mockQRResults;
    }),
    isQRCodeDetectionSupported: jest.fn().mockReturnValue(true)
  }
}));

jest.mock('../../utils/PageContentExtractor', () => ({
  PageContentExtractor: jest.fn().mockImplementation(() => ({
    extractHeadings: jest.fn().mockResolvedValue(mockHeadings),
    findBestHeadingForArea: jest.fn().mockImplementation((_, coordinates) => {
      // Find closest heading to QR code
      if (coordinates.x < 200) return 'Product Overview';
      return 'Contact Information';
    })
  }))
}));

jest.mock('../../utils/AutoCTAGenerator', () => ({
  AutoCTAGenerator: jest.fn().mockImplementation(() => ({
    createFromQRCode: jest.fn().mockImplementation((qrResult, pageNumber, heading, userId, documentId) => ({
      id: `auto-cta-${Date.now()}-${Math.random()}`,
      userId,
      documentId,
      pageNumber,
      url: qrResult.content.startsWith('http') ? qrResult.content : `http://test.com/${qrResult.content}`,
      label: heading || `QR Code Link - Page ${pageNumber}`,
      coordinates: qrResult.coordinates,
      isAutoGenerated: true,
      qrCodeContent: qrResult.content,
      autoGeneratedAt: new Date(),
      createdAt: new Date(),
      updatedAt: new Date()
    }))
  }))
}));

// Mock requestIdleCallback for background processing
global.requestIdleCallback = jest.fn((callback) => {
  const deadline = { 
    timeRemaining: () => 100,
    didTimeout: false
  };
  setTimeout(() => callback(deadline), 50);
  return 1;
});

global.cancelIdleCallback = jest.fn();

describe('QR Code End-to-End Integration Tests', () => {
  let user: ReturnType<typeof userEvent.setup>;

  beforeEach(() => {
    user = userEvent.setup();
    global.URL.createObjectURL = jest.fn(() => 'mock-pdf-url');
    global.URL.revokeObjectURL = jest.fn();
    
    // Mock localStorage
    const mockStorage: { [key: string]: string } = {};
    Object.defineProperty(window, 'localStorage', {
      value: {
        getItem: jest.fn((key: string) => mockStorage[key] || null),
        setItem: jest.fn((key: string, value: string) => {
          mockStorage[key] = value;
        }),
        removeItem: jest.fn((key: string) => {
          delete mockStorage[key];
        }),
        clear: jest.fn(() => {
          Object.keys(mockStorage).forEach(key => delete mockStorage[key]);
        }),
      },
    });

    jest.clearAllMocks();
  });

  describe('Complete QR Code Detection Workflow', () => {
    it('should complete full workflow from PDF upload to CTA creation', async () => {
      // Step 1: Render application with user logged in
      renderWithProviders(
        <PDFViewerContainer enableVirtualization={false} />,
        { initialUser: { id: 'test-user', name: 'Test User' } }
      );

      // Step 2: Upload PDF with QR codes
      const mockFile = createMockPdfFile('qr-test-document.pdf');
      const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
      
      await act(async () => {
        await user.upload(fileInput, mockFile);
      });

      // Step 3: Wait for PDF to load
      await waitFor(() => {
        expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      }, { timeout: 5000 });

      // Step 4: Wait for QR scanning to complete
      await waitFor(() => {
        // Check if QR scanning progress is shown
        const progressElement = screen.queryByText(/scanning.*qr/i);
        if (progressElement) {
          // Wait for scanning to complete
          return waitFor(() => {
            expect(screen.queryByText(/scanning.*qr/i)).not.toBeInTheDocument();
          }, { timeout: 3000 });
        }
        return Promise.resolve();
      }, { timeout: 5000 });

      // Step 5: Wait for QR scanning to complete (background process)
      await new Promise(resolve => setTimeout(resolve, 1000));

      // Step 6: Verify QR scanning utilities were called
      expect(QRCodeScannerService.getInstance).toHaveBeenCalled();
      expect(PageContentExtractor).toHaveBeenCalled();
      expect(AutoCTAGenerator).toHaveBeenCalled();

      // Step 7: Verify the workflow completed successfully
      // In a mocked environment, we verify that the scanning process was initiated
      // and the PDF viewer remains functional
      expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
    });

    it('should handle PDF upload with QR codes through complete CTA creation', async () => {
      renderWithProviders(
        <PDFViewerContainer enableVirtualization={false} />,
        { initialUser: { id: 'test-user', name: 'Test User' } }
      );

      // Upload PDF
      const mockFile = createMockPdfFile('comprehensive-qr-test.pdf');
      const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
      await user.upload(fileInput, mockFile);

      // Wait for PDF load
      await waitFor(() => {
        expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      });

      // Wait for background QR scanning
      await new Promise(resolve => setTimeout(resolve, 1000));

      // Verify scanning process completed without errors
      expect(screen.queryByText(/error.*scanning/i)).not.toBeInTheDocument();

      // Check that CTAs were created and stored
      await waitFor(() => {
        expect(localStorage.setItem).toHaveBeenCalledWith(
          expect.stringContaining('ctas'),
          expect.any(String)
        );
      });

      // Verify auto-generated CTAs have correct properties
      const setItemCalls = (localStorage.setItem as jest.Mock).mock.calls;
      const ctaCall = setItemCalls.find(call => call[0].includes('ctas'));
      
      if (ctaCall) {
        const ctaData = JSON.parse(ctaCall[1]);
        expect(Array.isArray(ctaData)).toBe(true);
        
        if (ctaData.length > 0) {
          const autoCTA = ctaData.find((cta: any) => cta.isAutoGenerated);
          expect(autoCTA).toBeDefined();
          expect(autoCTA.qrCodeContent).toBeDefined();
          expect(autoCTA.autoGeneratedAt).toBeDefined();
        }
      }
    });

    it('should integrate QR scanning with existing annotation system', async () => {
      renderWithProviders(
        <PDFViewerContainer enableVirtualization={false} />,
        { initialUser: { id: 'test-user', name: 'Test User' } }
      );

      // Upload PDF
      const mockFile = createMockPdfFile('annotation-integration-test.pdf');
      const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
      await user.upload(fileInput, mockFile);

      await waitFor(() => {
        expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      });

      // Wait for QR scanning
      await new Promise(resolve => setTimeout(resolve, 1000));

      // Create manual annotation alongside auto-generated CTAs
      const pdfPage = screen.getByTestId('pdf-page-1');
      
      // Create manual highlight
      fireEvent.mouseUp(pdfPage);
      
      await waitFor(() => {
        const highlightButton = screen.queryByText(/create highlight/i);
        if (highlightButton) {
          fireEvent.click(highlightButton);
        }
      });

      // Verify both manual and auto-generated annotations coexist
      await waitFor(() => {
        // Check for highlight overlay
        const highlights = screen.queryAllByTestId(/highlight.*overlay/i);
        // Check for auto-generated CTA overlays
        const ctas = screen.queryAllByTestId(/cta.*overlay/i);
        
        expect(highlights.length + ctas.length).toBeGreaterThan(0);
      });

      // Verify data isolation - all annotations belong to correct user
      const storageKeys = Object.keys(localStorage);
      const userSpecificKeys = storageKeys.filter(key => key.includes('test-user'));
      expect(userSpecificKeys.length).toBeGreaterThan(0);
    });
  });

  describe('User Settings Integration', () => {
    it('should respect QR code detection settings', async () => {
      // Pre-configure settings to disable QR scanning
      const mockStorage: { [key: string]: string } = {
        'ebook-utility-test-user-qr-settings': JSON.stringify({
          enabled: false,
          scanOnUpload: false,
          baseUrl: 'http://test.com/',
          maxScansPerDocument: 100,
          scanTimeout: 5000
        })
      };

      Object.defineProperty(window, 'localStorage', {
        value: {
          getItem: jest.fn((key: string) => mockStorage[key] || null),
          setItem: jest.fn((key: string, value: string) => {
            mockStorage[key] = value;
          }),
          removeItem: jest.fn(),
          clear: jest.fn(),
        },
      });

      renderWithProviders(
        <PDFViewerContainer enableVirtualization={false} />,
        { initialUser: { id: 'test-user', name: 'Test User' } }
      );

      // Upload PDF
      const mockFile = createMockPdfFile('settings-test.pdf');
      const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
      await user.upload(fileInput, mockFile);

      await waitFor(() => {
        expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      });

      // Wait and verify QR scanning was not initiated
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // QR scanner should not have been called due to disabled setting
      expect(QRCodeScannerService.getInstance).not.toHaveBeenCalled();
    });

    it('should allow enabling QR detection through settings', async () => {
      renderWithProviders(
        <PDFViewerContainer enableVirtualization={false} />,
        { initialUser: { id: 'test-user', name: 'Test User' } }
      );

      // Access settings (assuming there's a settings button/menu)
      const settingsButton = screen.queryByRole('button', { name: /settings/i });
      if (settingsButton) {
        await user.click(settingsButton);

        // Look for QR code settings
        const qrSettingsToggle = screen.queryByLabelText(/enable.*qr.*detection/i);
        if (qrSettingsToggle) {
          await user.click(qrSettingsToggle);
        }
      }

      // Upload PDF after enabling settings
      const mockFile = createMockPdfFile('settings-enabled-test.pdf');
      const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
      await user.upload(fileInput, mockFile);

      await waitFor(() => {
        expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      });

      // Wait for QR scanning
      await new Promise(resolve => setTimeout(resolve, 1000));

      // Verify QR scanning was initiated
      expect(QRCodeScannerService.getInstance).toHaveBeenCalled();
    });

    it('should persist QR settings across sessions', async () => {
      const { rerender } = renderWithProviders(
        <PDFViewerContainer enableVirtualization={false} />,
        { initialUser: { id: 'test-user', name: 'Test User' } }
      );

      // Simulate settings change
      const mockStorage: { [key: string]: string } = {
        'ebook-utility-test-user-qr-settings': JSON.stringify({
          enabled: true,
          scanOnUpload: true,
          baseUrl: 'http://custom.com/',
          maxScansPerDocument: 50,
          scanTimeout: 3000
        })
      };

      Object.defineProperty(window, 'localStorage', {
        value: {
          getItem: jest.fn((key: string) => mockStorage[key] || null),
          setItem: jest.fn(),
          removeItem: jest.fn(),
          clear: jest.fn(),
        },
      });

      // Re-render to simulate new session
      rerender(<PDFViewerContainer enableVirtualization={false} />);

      // Upload PDF
      const mockFile = createMockPdfFile('persistence-test.pdf');
      const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
      await user.upload(fileInput, mockFile);

      await waitFor(() => {
        expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      });

      // Verify settings were loaded and applied
      expect(localStorage.getItem).toHaveBeenCalledWith(
        expect.stringContaining('qr-settings')
      );
    });
  });

  describe('Error Scenarios', () => {
    it('should handle corrupted PDFs gracefully', async () => {
      renderWithProviders(
        <PDFViewerContainer enableVirtualization={false} />,
        { initialUser: { id: 'test-user', name: 'Test User' } }
      );

      // Create corrupted PDF file
      const corruptedFile = new File(['corrupted content'], 'corrupted.pdf', { 
        type: 'application/pdf' 
      });

      const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
      await user.upload(fileInput, corruptedFile);

      // Should show error message
      await waitFor(() => {
        expect(screen.getByText(/error.*loading.*pdf/i)).toBeInTheDocument();
      });

      // QR scanning should not be initiated for corrupted files
      expect(QRCodeScannerService.getInstance).not.toHaveBeenCalled();

      // Should still show upload interface for recovery
      expect(screen.getByText(/drag and drop/i)).toBeInTheDocument();
    });

    it('should handle QR scanning failures without breaking PDF viewer', async () => {
      // Mock QR scanner to throw error
      (QRCodeScannerService.getInstance as jest.Mock).mockReturnValue({
        scanPage: jest.fn().mockRejectedValue(new Error('QR scanning failed')),
        isQRCodeDetectionSupported: jest.fn().mockReturnValue(true)
      });

      renderWithProviders(
        <PDFViewerContainer enableVirtualization={false} />,
        { initialUser: { id: 'test-user', name: 'Test User' } }
      );

      const mockFile = createMockPdfFile('qr-error-test.pdf');
      const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
      await user.upload(fileInput, mockFile);

      // PDF should still load successfully
      await waitFor(() => {
        expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      });

      // Wait for QR scanning attempt
      await new Promise(resolve => setTimeout(resolve, 1000));

      // PDF viewer should remain functional - check for page indicator
      expect(screen.getByDisplayValue('1')).toBeInTheDocument(); // Page input shows current page
      
      // Navigation should still work
      const nextButton = screen.getByRole('button', { name: /next page/i });
      await user.click(nextButton);

      await waitFor(() => {
        expect(screen.getByText(/page 2 of 5/i)).toBeInTheDocument();
      });
    });

    it('should handle invalid QR codes without crashing', async () => {
      // Mock QR scanner to return invalid results
      (QRCodeScannerService.getInstance as jest.Mock).mockReturnValue({
        scanPage: jest.fn().mockResolvedValue([
          {
            content: '', // Empty content
            coordinates: { x: 100, y: 200, width: 80, height: 80 },
            confidence: 0.1 // Low confidence
          },
          {
            content: null, // Null content
            coordinates: { x: 200, y: 300, width: 80, height: 80 },
            confidence: 0.95
          }
        ]),
        isQRCodeDetectionSupported: jest.fn().mockReturnValue(true)
      });

      renderWithProviders(
        <PDFViewerContainer enableVirtualization={false} />,
        { initialUser: { id: 'test-user', name: 'Test User' } }
      );

      const mockFile = createMockPdfFile('invalid-qr-test.pdf');
      const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
      await user.upload(fileInput, mockFile);

      await waitFor(() => {
        expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      });

      // Wait for QR scanning
      await new Promise(resolve => setTimeout(resolve, 1000));

      // Application should remain stable
      expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      expect(screen.queryByText(/error/i)).not.toBeInTheDocument();
    });

    it('should provide user-friendly error messages', async () => {
      // Mock unsupported browser scenario
      (QRCodeScannerService.getInstance as jest.Mock).mockReturnValue({
        scanPage: jest.fn(),
        isQRCodeDetectionSupported: jest.fn().mockReturnValue(false)
      });

      renderWithProviders(
        <PDFViewerContainer enableVirtualization={false} />,
        { initialUser: { id: 'test-user', name: 'Test User' } }
      );

      const mockFile = createMockPdfFile('unsupported-test.pdf');
      const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
      await user.upload(fileInput, mockFile);

      await waitFor(() => {
        expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      });

      // Should show user-friendly message about unsupported feature
      await waitFor(() => {
        const message = screen.queryByText(/qr.*not.*supported/i);
        if (message) {
          expect(message).toBeInTheDocument();
        }
      });

      // PDF functionality should remain unaffected - check for page indicator
      expect(screen.getByDisplayValue('1')).toBeInTheDocument(); // Page input shows current page
    });
  });

  describe('Browser Compatibility', () => {
    it('should detect browser support for QR code functionality', async () => {
      renderWithProviders(
        <PDFViewerContainer enableVirtualization={false} />,
        { initialUser: { id: 'test-user', name: 'Test User' } }
      );

      const mockFile = createMockPdfFile('compatibility-test.pdf');
      const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
      await user.upload(fileInput, mockFile);

      await waitFor(() => {
        expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      });

      // Verify browser support check was called
      expect(QRCodeScannerService.getInstance).toHaveBeenCalled();
    });

    it('should gracefully degrade on unsupported browsers', async () => {
      // Mock unsupported browser
      (QRCodeScannerService.getInstance as jest.Mock).mockReturnValue({
        scanPage: jest.fn(),
        isQRCodeDetectionSupported: jest.fn().mockReturnValue(false)
      });

      renderWithProviders(
        <PDFViewerContainer enableVirtualization={false} />,
        { initialUser: { id: 'test-user', name: 'Test User' } }
      );

      const mockFile = createMockPdfFile('degradation-test.pdf');
      const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
      await user.upload(fileInput, mockFile);

      await waitFor(() => {
        expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      });

      // Core PDF functionality should work - check for page indicator
      expect(screen.getByDisplayValue('1')).toBeInTheDocument(); // Page input shows current page
      
      // Manual annotation features should still be available
      const pdfPage = screen.getByTestId('pdf-page-1');
      fireEvent.click(pdfPage);
      
      // Should be able to create manual annotations
      await waitFor(() => {
        const commentOption = screen.queryByText(/add comment/i);
        if (commentOption) {
          expect(commentOption).toBeInTheDocument();
        }
      });
    });

    it('should handle Canvas API limitations', async () => {
      // Mock Canvas API failure
      const originalGetContext = HTMLCanvasElement.prototype.getContext;
      HTMLCanvasElement.prototype.getContext = jest.fn().mockReturnValue(null);

      renderWithProviders(
        <PDFViewerContainer enableVirtualization={false} />,
        { initialUser: { id: 'test-user', name: 'Test User' } }
      );

      const mockFile = createMockPdfFile('canvas-test.pdf');
      const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
      await user.upload(fileInput, mockFile);

      await waitFor(() => {
        expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      });

      // Should handle canvas failure gracefully
      expect(screen.getByTestId('pdf-document')).toBeInTheDocument();

      // Restore original method
      HTMLCanvasElement.prototype.getContext = originalGetContext;
    });
  });

  describe('Performance and Scalability', () => {
    it('should handle large PDFs with multiple QR codes efficiently', async () => {
      // Mock multiple QR codes across pages
      const manyQRResults = Array.from({ length: 20 }, (_, i) => ({
        content: `https://example.com/item${i}`,
        coordinates: { x: 100 + (i % 5) * 100, y: 200 + Math.floor(i / 5) * 100, width: 80, height: 80 },
        confidence: 0.9
      }));

      (QRCodeScannerService.getInstance as jest.Mock).mockReturnValue({
        scanPage: jest.fn().mockResolvedValue(manyQRResults.slice(0, 4)), // 4 QR codes per page
        isQRCodeDetectionSupported: jest.fn().mockReturnValue(true)
      });

      renderWithProviders(
        <PDFViewerContainer enableVirtualization={false} />,
        { initialUser: { id: 'test-user', name: 'Test User' } }
      );

      const startTime = performance.now();

      const mockFile = createMockPdfFile('large-qr-test.pdf');
      const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
      await user.upload(fileInput, mockFile);

      await waitFor(() => {
        expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      });

      // Wait for QR scanning to complete
      await new Promise(resolve => setTimeout(resolve, 2000));

      const endTime = performance.now();
      const processingTime = endTime - startTime;

      // Should complete within reasonable time
      expect(processingTime).toBeLessThan(10000); // 10 seconds

      // UI should remain responsive
      expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      expect(screen.getByDisplayValue('1')).toBeInTheDocument(); // Page input shows current page
    });

    it('should not block UI during background QR scanning', async () => {
      renderWithProviders(
        <PDFViewerContainer enableVirtualization={false} />,
        { initialUser: { id: 'test-user', name: 'Test User' } }
      );

      const mockFile = createMockPdfFile('ui-responsiveness-test.pdf');
      const fileInput = document.querySelector('#pdf-upload-input') as HTMLInputElement;
      await user.upload(fileInput, mockFile);

      await waitFor(() => {
        expect(screen.getByTestId('pdf-document')).toBeInTheDocument();
      });

      // Immediately test UI responsiveness while QR scanning might be running
      const nextButton = screen.getByRole('button', { name: /next page/i });
      await user.click(nextButton);

      // Navigation should work immediately
      await waitFor(() => {
        expect(screen.getByDisplayValue('2')).toBeInTheDocument(); // Page input shows page 2
      });

      // Go back to page 1
      const prevButton = screen.getByRole('button', { name: /previous page/i });
      await user.click(prevButton);

      await waitFor(() => {
        expect(screen.getByText(/page 1 of 5/i)).toBeInTheDocument();
      });
    });
  });
});