# Design Document

## Overview

The QR Code Auto-Detection feature extends the existing PDF reader by automatically scanning uploaded PDFs for QR codes and creating call-to-action links. The system will integrate with the existing annotation architecture, using background processing to scan pages without blocking the user interface. QR codes will be decoded and combined with page context (headings) to create meaningful, clickable call-to-action elements.

## Architecture

### High-Level Flow
1. **PDF Upload** → Existing PDF processing pipeline
2. **QR Detection** → Background scanning service processes each page
3. **Content Extraction** → Extract QR code data and page headings
4. **CTA Creation** → Generate call-to-action annotations using existing data structures
5. **UI Integration** → Display auto-generated CTAs alongside manual annotations

### Core Components
- **QRCodeScanner**: Service for detecting and decoding QR codes from PDF pages
- **PageContentExtractor**: Utility for extracting headings and text from PDF pages
- **AutoCTAGenerator**: Factory for creating call-to-action annotations from QR data
- **QRScanningManager**: Orchestrates the scanning process and manages state
- **QRCodeSettings**: User preferences for QR code auto-detection

## Components and Interfaces

### QRCodeScanner Service

```typescript
interface QRCodeScanResult {
  content: string;
  coordinates: RectangleCoordinates;
  confidence: number;
}

interface QRCodeScanner {
  scanPage(pageCanvas: HTMLCanvasElement): Promise<QRCodeScanResult[]>;
  isQRCodeDetectionSupported(): boolean;
}
```

**Implementation Details:**
- Uses `jsQR` library for QR code detection from canvas elements
- Processes PDF pages rendered to canvas by react-pdf
- Returns coordinates for positioning CTAs
- Handles multiple QR codes per page
- Provides confidence scoring for detection quality

### PageContentExtractor Utility

```typescript
interface PageHeading {
  text: string;
  level: number; // 1-6 for heading hierarchy
  coordinates: RectangleCoordinates;
}

interface PageContentExtractor {
  extractHeadings(pageNumber: number, pdfDocument: PDFDocument): Promise<PageHeading[]>;
  findBestHeadingForArea(headings: PageHeading[], qrCoordinates: RectangleCoordinates): string | null;
}
```

**Implementation Details:**
- Uses pdf-lib to extract text content and positioning
- Identifies headings based on font size, weight, and positioning
- Finds the most relevant heading near QR code location
- Provides fallback title generation

### AutoCTAGenerator Factory

```typescript
interface AutoCTAConfig {
  baseUrl: string; // "http://test.com/"
  maxTitleLength: number; // 50 characters
  defaultTitleTemplate: string; // "QR Code Link - Page {pageNumber}"
}

interface AutoCTAGenerator {
  createFromQRCode(
    qrResult: QRCodeScanResult,
    pageNumber: number,
    pageHeading: string | null,
    userId: string,
    documentId: string
  ): CallToAction;
}
```

**Implementation Details:**
- Extends existing CallToAction type with `isAutoGenerated: boolean` flag
- Generates URLs by combining base URL with QR code content
- Creates meaningful titles from page headings or defaults
- Maintains compatibility with existing CTA data structure

### QRScanningManager

```typescript
interface QRScanningState {
  isScanning: boolean;
  currentPage: number;
  totalPages: number;
  foundQRCodes: number;
  errors: string[];
}

interface QRScanningManager {
  startScanning(pdfDocument: PDFDocument, userId: string, documentId: string): Promise<void>;
  pauseScanning(): void;
  resumeScanning(): void;
  getState(): QRScanningState;
  onStateChange(callback: (state: QRScanningState) => void): void;
}
```

**Implementation Details:**
- Manages background scanning process
- Provides progress updates and error handling
- Integrates with existing AnnotationContext
- Supports pause/resume for performance management

## Data Models

### Extended CallToAction Type

```typescript
interface CallToAction extends BaseAnnotation {
  url: string;
  label: string;
  coordinates: RectangleCoordinates;
  isAutoGenerated?: boolean; // New field for QR-generated CTAs
  qrCodeContent?: string; // Original QR code content
  autoGeneratedAt?: Date; // When auto-generation occurred
}
```

### QR Code Settings

```typescript
interface QRCodeSettings {
  enabled: boolean;
  scanOnUpload: boolean;
  baseUrl: string;
  maxScansPerDocument: number;
  scanTimeout: number; // milliseconds per page
}
```

### QR Scanning Progress

```typescript
interface QRScanProgress {
  documentId: string;
  totalPages: number;
  scannedPages: number;
  foundQRCodes: QRCodeScanResult[];
  generatedCTAs: CallToAction[];
  errors: Array<{
    pageNumber: number;
    error: string;
  }>;
  startedAt: Date;
  completedAt?: Date;
}
```

## Error Handling

### QR Code Detection Errors
- **Library Load Failure**: Graceful degradation if jsQR fails to load
- **Canvas Rendering Issues**: Skip problematic pages, continue scanning
- **Invalid QR Codes**: Log but don't interrupt process
- **Memory Constraints**: Implement page-by-page processing with cleanup

### Error Recovery Strategies
- Retry failed pages up to 3 times
- Skip pages that consistently fail
- Provide user notification of partial failures
- Maintain detailed error logs for debugging

### User-Facing Error Messages
- "QR code scanning partially completed - some pages could not be processed"
- "QR code detection is not supported in this browser"
- "Scanning paused due to performance constraints"

## Testing Strategy

### Unit Tests
- **QRCodeScanner**: Mock canvas elements, test QR detection accuracy
- **PageContentExtractor**: Test heading extraction from sample PDFs
- **AutoCTAGenerator**: Verify URL generation and title creation logic
- **QRScanningManager**: Test state management and error handling

### Integration Tests
- **End-to-End QR Flow**: Upload PDF with QR codes, verify CTA creation
- **Performance Testing**: Large PDFs with multiple QR codes
- **Error Scenarios**: Corrupted PDFs, invalid QR codes, network failures
- **User Settings**: Enable/disable functionality, preference persistence

### Test Data Requirements
- Sample PDFs with various QR code types (URLs, text, positioning)
- PDFs with different heading structures and fonts
- Large PDFs for performance testing
- Corrupted/invalid PDF files for error testing

### Browser Compatibility Testing
- Chrome 80+, Firefox 75+, Safari 13+, Edge 80+
- Mobile browsers (iOS Safari, Chrome Mobile)
- Canvas API support verification
- Performance across different devices

## Performance Considerations

### Background Processing
- Use Web Workers for QR code scanning to avoid UI blocking
- Process pages incrementally with requestIdleCallback
- Implement cancellation for user navigation away from document

### Memory Management
- Release canvas elements after processing each page
- Limit concurrent page processing (max 2-3 pages)
- Clean up QR detection resources promptly

### User Experience Optimizations
- Prioritize visible pages for scanning
- Show progress indicator for long-running scans
- Allow users to continue reading while scanning occurs
- Cache scan results to avoid re-processing

### Scalability Limits
- Maximum 100 QR codes per document
- Timeout individual page scans after 5 seconds
- Skip scanning for PDFs larger than 50MB
- Provide user control over scanning intensity

## Integration Points

### Existing Annotation System
- Auto-generated CTAs use same storage mechanism as manual CTAs
- Integrate with AnnotationContext for state management
- Support existing CTA editing and deletion workflows
- Maintain user isolation and document association

### PDF Processing Pipeline
- Hook into existing PDF upload and rendering flow
- Use react-pdf canvas rendering for QR detection
- Coordinate with existing page virtualization
- Respect existing error boundaries and loading states

### User Interface Integration
- Add QR scanning toggle to settings/preferences
- Show scanning progress in PDF viewer
- Distinguish auto-generated CTAs in annotation lists
- Provide bulk management options for auto-generated CTAs

### Settings and Preferences
- Extend existing user preferences system
- Persist QR scanning settings in localStorage
- Provide granular control over auto-generation behavior
- Allow users to modify base URL and other parameters